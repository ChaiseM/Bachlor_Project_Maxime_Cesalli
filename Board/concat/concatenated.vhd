-- VHDL Entity Board.FPGA_splitter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 16:50:18 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FPGA_splitter IS
    GENERIC( 
        buttonNb : positive := 4;
        ledNb    : positive := 8
    );
    PORT( 
        CLK_In  : IN     std_uLogic;
        Data_In : IN     std_uLogic;
        LR_In   : IN     std_uLogic;
        RxD     : IN     std_uLogic;
        S20     : IN     std_ulogic;
        S21     : IN     std_ulogic;
        S22     : IN     std_ulogic;
        S23     : IN     std_ulogic;
        S30     : IN     std_ulogic;
        S31     : IN     std_ulogic;
        S32     : IN     std_ulogic;
        S33     : IN     std_ulogic;
        S40     : IN     std_ulogic;
        S41     : IN     std_ulogic;
        S42     : IN     std_ulogic;
        S43     : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset_n : IN     std_ulogic;
        CLK_O   : OUT    std_uLogic;
        Data_O  : OUT    std_uLogic;
        LR_O    : OUT    std_ulogic;
        testOut : OUT    std_ulogic_vector (6 DOWNTO 0)
    );

-- Declarations

END FPGA_splitter ;





-- VHDL Entity Splitter.leftRightSplitter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 17:01:31 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY leftRightSplitter IS
    GENERIC( 
        signalBitNb  : positive := 24;
        signalOBitNb : positive := 32
    );
    PORT( 
        CLK_I     : IN     std_uLogic;
        Data_I    : IN     std_uLogic;
        LR_I      : IN     std_uLogic;
        RxD_synch : IN     std_ulogic;
        S21       : IN     std_ulogic;
        S22       : IN     std_ulogic;
        S23       : IN     std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        CLK_O     : OUT    std_uLogic;
        Data_O    : OUT    std_uLogic;
        LR_O      : OUT    std_ulogic;
        testOut   : OUT    std_ulogic_vector (6 DOWNTO 0)
    );

-- Declarations

END leftRightSplitter ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




-- VHDL Entity Splitter.iisDecoder.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:43:50 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY iisDecoder IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        reset      : IN     std_ulogic;
        clock      : IN     std_ulogic;
        LRCK       : IN     std_ulogic;
        SCK        : IN     std_ulogic;
        DOUT       : IN     std_ulogic;
        dataValid  : OUT    std_ulogic;
        audioLeft  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        lr2        : OUT    std_ulogic
    );

-- Declarations

END iisDecoder ;





--------------------------------------------------------------------------------
-- decoding the i2s input to DATA_WIDTH registers 
--------------------------------------------------------------------------------
ARCHITECTURE MYArchi OF iisDecoder IS
   signal sckDelayed, sckRising, sckFalling : std_ulogic;
   signal lrckDelayed, lrckChanged : std_ulogic;
   signal lrSel1, lrSel : std_ulogic;
   signal lrCounter1, lrCounter : unsigned(4 downto 0); -- count to 32
BEGIN

   delaySck : process (reset, clock)
   begin
      if reset = '1' then
         sckDelayed <= '0';
         lrckDelayed <= '0';
      elsif rising_edge(clock) then
         -- 1 clock period delay to detect the edges
         sckDelayed <= SCK;
         lrckDelayed <= LRCK;
      end if;
   end process delaySck;
   -- edges detection
   sckRising <= '1' when (SCK = '1') and (sckDelayed = '0') else '0';
   sckFalling <= '1' when (SCK = '0') and (sckDelayed = '1')else '0';
   lrckChanged <= '1' when LRCK /= lrckDelayed else '0';
   
   
   countBits : process (reset, clock)
   begin
      if reset = '1' then
         lrCounter1 <= (others => '1');
         lrCounter <= (others => '1');
      elsif rising_edge(clock) then
         
         if lrckChanged = '1' then
            -- reseting the lr counter1
            lrCounter1 <= (others => '1');
         elsif sckRising = '1' then
            -- substracting the LRcounter1 at the rising edge
            lrCounter1 <= lrCounter1 - 1;
         end if;
         if sckFalling = '1' then
            -- updating the counter at the falling edge 
            -- (+1 because of the nature of the i2s protocole)
            lrCounter <= lrCounter1 + 1;
         end if;
      end if;
   end process countBits;
   
   shiftLrSel : process (reset, clock)
   begin
      if reset = '1' then
         lrSel1 <= '0';
         lrSel <= '0';
      elsif rising_edge(clock) then
         -- shifting the LR to comply with the i2s protocole
         if sckRising = '1' then
            lrSel1 <= LRCK;
         elsif sckFalling = '1' then
            lrSel <= lrSel1;
         end if;
      end if;
   end process shiftLrSel;
   
   fillReg : process (clock, reset)
   begin
      if reset = '1' then
         audioLeft <= (others => '0');
         audioRight <= (others => '0');
      elsif rising_edge(clock) then
         if sckRising = '1' then
         -- updating the outputs bits in function of leSel and lrCounter
            if lrSel = '1' then 
               audioLeft(to_integer(lrCounter)) <= DOUT;
            else
               audioRight(to_integer(lrCounter)) <= DOUT;
            end if;
         end if;
      end if;
   end process fillReg;
   lr2 <= lrSel;
   dataValid <= '1' when lrCounter = 0 and SCK = '1' and LRCK = '1' else '0';
   --dataValid <= '1' when lrCounter = 0 and SCK = '1' else '0';
END ARCHITECTURE MYArchi;



-- VHDL Entity Splitter_test.bascule.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:27:20 09.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY bascule IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        audio_L_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock       : IN     std_ulogic;
        dataVAlid   : IN     std_ulogic;
        reset       : IN     std_ulogic;
        audio_L_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );

-- Declarations

END bascule ;





--------------------------------------------------------------
-- register to sync the iis decoder with the others blocks 
--------------------------------------------------------------
ARCHITECTURE test_lowpas_i2s OF bascule IS
   signal cnt :  unsigned (2 downto 0);
BEGIN
   FlipFlopAndResize: process(reset, clock)
   begin
      if reset = '1' then
         audio_R_out <= (others => '0');
         audio_L_out <= (others => '0');
         cnt <= (others => '0');
      elsif rising_edge(clock) then
         if dataValid = '1' then
            audio_R_out <= audio_R_in;
            audio_L_out <= audio_L_in;      
         end if;             
      end if;
   end process FlipFlopAndResize;
END ARCHITECTURE test_lowpas_i2s;





-- VHDL Entity Splitter.CoeffWriter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 11:40:49 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY CoeffWriter IS
    GENERIC( 
        addressBitNb  : positive;
        dataBitNb     : positive;
        COEFF_BIT_NB  : positive;
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive
    );
    PORT( 
        clock    : IN     std_ulogic;
        reset    : IN     std_ulogic;
        addressB : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB      : OUT    std_ulogic;
        writeEnB : OUT    std_ulogic
    );

-- Declarations

END CoeffWriter ;





--
-- VHDL Architecture Splitter.CoeffWriter.Archi1
--
-- Created:
-- by - maxime.cesalli.UNKNOWN (WE2330804)
-- at - 15:22:31 18.07.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE Archi1 OF CoeffWriter IS
   constant HALF_FILTER_TAP_NB : positive := FILTER_TAP_NB/2 + (FILTER_TAP_NB mod 2);
   signal firstWrite : unsigned(3 downto 0);
   signal wAddrCnt : unsigned(addressBitNb - 1 downto 0);
   signal arrayCnt : unsigned(addressBitNb - 1 downto 0);
   signal writeCoeffs : std_ulogic;

   constant n : positive := 1;
   constant initialWAddress : integer := 1502;
   constant RAMLength : positive := (((FILTER_TAP_NB * n * 2) + initialWAddress) - 1);
   -- lowpass firtst then highpass coeff
   type coefficients is array (0 to 1, 0 to HALF_FILTER_TAP_NB - 1) of signed(COEFF_BIT_NB - 1 downto 0);
   signal coeff : coefficients := (
      (
      x"FFFFF25F", x"FFFFECE9", x"FFFFE8CC", x"FFFFE6DD", x"FFFFE7C9", 
      x"FFFFEBF3", x"FFFFF362", x"FFFFFDAB", x"000009F4", x"00001700", 
      x"00002348", x"00002D24", x"00003303", x"0000339A", x"00002E1D", 
      x"00002264", x"0000110A", x"FFFFFB6E", x"FFFFE39C", x"FFFFCC2B", 
      x"FFFFB7F0", x"FFFFA9B5", x"FFFFA3DC", x"FFFFA80B", x"FFFFB6E3", 
      x"FFFFCFD3", x"FFFFF10A", x"00001785", x"00003F5A", x"00006409", 
      x"000080FF", x"0000921A", x"00009436", x"0000859D", x"00006664", 
      x"0000388D", x"00000000", x"FFFFC23A", x"FFFF85D3", x"FFFF51D2", 
      x"FFFF2CE8", x"FFFF1C9C", x"FFFF2494", x"FFFF45FC", x"FFFF7F30", 
      x"FFFFCBB0", x"0000246A", x"00008052", x"0000D543", x"00011914", 
      x"000142C0", x"00014B86", x"00012FD9", x"0000F007", x"00009080", 
      x"0000199B", x"FFFF96F7", x"FFFF1660", x"FFFEA66A", x"FFFE54DA", 
      x"FFFE2D05", x"FFFE365C", x"FFFE734F", x"FFFEE0AB", x"FFFF7597", 
      x"00002428", x"0000DAA4", x"00018536", x"0002100D", x"0002698F", 
      x"00028480", x"000259C4", x"0001E993", x"00013BEB", x"00006029", 
      x"FFFF6BCB", x"FFFE7866", x"FFFDA110", x"FFFCFF70", x"FFFCA8C3", 
      x"FFFCAB3F", x"FFFD0C0B", x"FFFDC620", x"FFFECA3D", x"00000000", 
      x"00014811", x"00027F3A", x"00038214", x"000430FB", x"000473C5", 
      x"00043CE4", x"00038B7C", x"00026C3B", x"0000F8AA", x"FFFF5515", 
      x"FFFDAD18", x"FFFC2F34", x"FFFB07CE", x"FFFA5C23", x"FFFA45C9", 
      x"FFFACF3A", x"FFFBF1D7", x"FFFD95C3", x"FFFF939B", x"0001B7FE", 
      x"0003C8A3", x"00058A65", x"0006C7C8", x"00075729", x"00071FED", 
      x"00061E1C", x"000463D5", x"0002186C", x"FFFF7522", x"FFFCBFB3", 
      x"FFFA434C", x"FFF84880", x"FFF70D2E", x"FFF6BD28", x"FFF76C85", 
      x"FFF91447", x"FFFB91D6", x"FFFEA97D", x"00020BCF", x"00055D76", 
      x"000840AC", x"000A5F6C", x"000B7543", x"000B57A1", x"0009FBB7", 
      x"00077918", x"000408AE", x"00000000", x"FFFBC917", x"FFF7D7C6", 
      x"FFF49D69", x"FFF27C59", x"FFF1BC7D", x"FFF2823D", x"FFF4C8FD", 
      x"FFF861D6", x"FFFCF6E2", x"000212F5", x"00072D24", x"000BB6DA", 
      x"000F2B43", x"00111E33", x"0011490D", x"000F9409", x"000C1AC5", 
      x"00072B63", x"00014015", x"FFFAF395", x"FFF4F18F", x"FFEFE498", 
      x"FFEC637C", x"FFEADFFB", x"FFEB98DC", x"FFEE9107", x"FFF38CCE", 
      x"FFFA15ED", x"0001861F", x"0009175A", x"000FF827", x"00156205", 
      x"0018AF82", x"00196F88", x"001773C1", x"0012D839", x"000C0330", 
      x"00039CD4", x"FFFA7F75", x"FFF1A1AB", x"FFE9FC91", x"FFE470B9", 
      x"FFE1ACCD", x"FFE218A8", x"FFE5C75B", x"FFEC71EA", x"FFF57BA6", 
      x"00000000", x"000AE8BF", x"00150A65", x"001D43F9", x"00229ED5", 
      x"00246B0B", x"0022551E", x"001C7278", x"001342EE", x"0007A6C5", 
      x"FFFAC9D0", x"FFEE05A0", x"FFE2BDA7", x"FFDA38F3", x"FFD57DA4", 
      x"FFD53221", x"FFD98790", x"FFE2304A", x"FFEE63C0", x"FFFCEFD3", 
      x"000C5647", x"001AF389", x"00272ADC", x"002F935C", x"003320FF", 
      x"003144EF", x"002A017E", x"001DEF05", x"000E30B3", x"FFFC59E4", 
      x"FFEA465C", x"FFD9E94F", x"FFCD1812", x"FFC5563A", x"FFC3A8B7", 
      x"FFC8751D", x"FFD37103", x"FFE3A3E2", x"FFF77BD7", x"000CF3C2", 
      x"0021C739", x"0033AF15", x"0040A082", x"004707B1", x"0045F7BF", 
      x"003D4A3F", x"002DAA60", x"001889DC", x"00000000", x"FFE695A5", 
      x"FFCF0314", x"FFBBE66A", x"FFAF7A3C", x"FFAB5455", x"FFB033FC", 
      x"FFBDE592", x"FFD33F71", x"FFEE3932", x"000C1BDC", x"0029C6A3", 
      x"0044018A", x"0057D57F", x"0062E0B5", x"00639DEE", x"0059969A", 
      x"004579A2", x"0029136E", x"000726DC", x"FFE32A36", x"FFC0EE60", 
      x"FFA438EC", x"FF905B96", x"FF87D443", x"FF8C0020", x"FF9CEAE0", 
      x"FFB94065", x"FFDE639C", x"0008A9A1", x"0033B422", x"005AE292", 
      x"0079CEF6", x"008CC966", x"009144F5", x"008629DC", x"006C0301", 
      x"00450089", x"0014CD75", x"FFE03AEF", x"FFACC891", x"FF8014F5", 
      x"FF5F44C5", x"FF4E702A", x"FF50266E", x"FF6515FD", x"FF8BE39D", 
      x"FFC13755", x"00000000", x"0041E8D9", x"007FF6ED", x"00B33FA3", 
      x"00D5A65D", x"00E28D9A", x"00D7686A", x"00B41B7B", x"007B2133", 
      x"00316A21", x"FFDDF99D", x"FF894575", x"FF3C6634", x"FF002ADC", 
      x"FEDC26FE", x"FED5D3A4", x"FEEFDAED", x"FF29A302", x"FF7F27DD", 
      x"FFE92C16", x"005DC0DD", x"00D11C8E", x"0136AF1D", x"01825CD8", 
      x"01A9C2F0", x"01A566FC", x"0171B30D", x"010FA375", x"00851168", 
      x"FFDC8E0B", x"FF24CB3D", x"FE6F9A09", x"FDD0908E", x"FD5B7247", 
      x"FD227C08", x"FD34B902", x"FD9C86B0", x"FE5E6A97", x"FF7856EF", 
      x"00E17239", x"028A6B21", x"045E560A", x"064405B3", x"081FC59A", 
      x"09D553BD", x"0B49F181", x"0C6660EC", x"0D18A46D", x"0D555C3F"
            ),
      (
      x"00000DA1", x"00001317", x"00001734", x"00001923", x"00001837", 
      x"0000140D", x"00000C9E", x"00000255", x"FFFFF60C", x"FFFFE900", 
      x"FFFFDCB9", x"FFFFD2DC", x"FFFFCCFD", x"FFFFCC66", x"FFFFD1E3", 
      x"FFFFDD9C", x"FFFFEEF6", x"00000492", x"00001C64", x"000033D5", 
      x"00004810", x"0000564A", x"00005C24", x"000057F5", x"0000491D", 
      x"0000302D", x"00000EF6", x"FFFFE87B", x"FFFFC0A6", x"FFFF9BF7", 
      x"FFFF7F02", x"FFFF6DE6", x"FFFF6BCA", x"FFFF7A63", x"FFFF999D", 
      x"FFFFC773", x"00000000", x"00003DC6", x"00007A2D", x"0000AE2D", 
      x"0000D317", x"0000E363", x"0000DB6B", x"0000BA04", x"000080D0", 
      x"00003450", x"FFFFDB97", x"FFFF7FAF", x"FFFF2ABE", x"FFFEE6ED", 
      x"FFFEBD40", x"FFFEB47B", x"FFFED028", x"FFFF0FF9", x"FFFF6F81", 
      x"FFFFE665", x"00006909", x"0000E9A0", x"00015995", x"0001AB25", 
      x"0001D2FA", x"0001C9A3", x"00018CB0", x"00011F54", x"00008A69", 
      x"FFFFDBD8", x"FFFF255D", x"FFFE7ACB", x"FFFDEFF5", x"FFFD9673", 
      x"FFFD7B82", x"FFFDA63D", x"FFFE166E", x"FFFEC416", x"FFFF9FD7", 
      x"00009435", x"00018799", x"00025EEE", x"0003008E", x"0003573B", 
      x"000354BF", x"0002F3F3", x"000239DF", x"000135C2", x"00000000", 
      x"FFFEB7F0", x"FFFD80C8", x"FFFC7DEE", x"FFFBCF08", x"FFFB8C3D", 
      x"FFFBC31F", x"FFFC7486", x"FFFD93C7", x"FFFF0757", x"0000AAEB", 
      x"000252E7", x"0003D0C9", x"0004F82F", x"0005A3DA", x"0005BA33", 
      x"000530C3", x"00040E27", x"00026A3B", x"00006C65", x"FFFE4803", 
      x"FFFC3760", x"FFFA759E", x"FFF9383C", x"FFF8A8DC", x"FFF8E017", 
      x"FFF9E1E8", x"FFFB9C2E", x"FFFDE795", x"00008ADE", x"0003404B", 
      x"0005BCB1", x"0007B77B", x"0008F2CD", x"000942D3", x"00089376", 
      x"0006EBB4", x"00046E27", x"00015682", x"FFFDF432", x"FFFAA28D", 
      x"FFF7BF59", x"FFF5A09A", x"FFF48AC4", x"FFF4A866", x"FFF6044F", 
      x"FFF886ED", x"FFFBF755", x"00000000", x"000436E6", x"00082835", 
      x"000B6290", x"000D839E", x"000E437B", x"000D7DBB", x"000B36FC", 
      x"00079E25", x"0003091C", x"FFFDED0C", x"FFF8D2E1", x"FFF4492D", 
      x"FFF0D4C6", x"FFEEE1D7", x"FFEEB6FD", x"FFF06C00", x"FFF3E542", 
      x"FFF8D4A1", x"FFFEBFEC", x"00050C68", x"000B0E6B", x"00101B5E", 
      x"00139C78", x"00151FF8", x"00146718", x"00116EEE", x"000C732A", 
      x"0005EA0F", x"FFFE79E2", x"FFF6E8AB", x"FFF007E3", x"FFEA9E08", 
      x"FFE7508D", x"FFE69087", x"FFE88C4D", x"FFED27D2", x"FFF3FCD7", 
      x"FFFC632F", x"00058088", x"000E5E4C", x"00160362", x"001B8F37", 
      x"001E5321", x"001DE746", x"001A3896", x"00138E0A", x"000A8454", 
      x"00000000", x"FFF51747", x"FFEAF5A7", x"FFE2BC19", x"FFDD6140", 
      x"FFDB950A", x"FFDDAAF6", x"FFE38D9A", x"FFECBD1D", x"FFF85940", 
      x"0005362D", x"0011FA55", x"001D4247", x"0025C6F7", x"002A8242", 
      x"002ACDC5", x"00267859", x"001DCFA4", x"00119C35", x"0003102C", 
      x"FFF3A9C1", x"FFE50C87", x"FFD8D53B", x"FFD06CC0", x"FFCCDF20", 
      x"FFCEBB2F", x"FFD5FE9B", x"FFE2110D", x"FFF1CF55", x"0003A61A", 
      x"0015B997", x"0026169A", x"0032E7CF", x"003AA9A3", x"003C5725", 
      x"00378AC2", x"002C8EE2", x"001C5C0D", x"00088424", x"FFF30C46", 
      x"FFDE38DB", x"FFCC510A", x"FFBF5FA5", x"FFB8F87A", x"FFBA086B", 
      x"FFC2B5E6", x"FFD255BC", x"FFE77632", x"00000000", x"00196A4C", 
      x"0030FCCF", x"0044196D", x"00508594", x"0054AB78", x"004FCBD4", 
      x"00421A46", x"002CC074", x"0011C6C4", x"FFF3E42C", x"FFD63976", 
      x"FFBBFE9F", x"FFA82AB6", x"FF9D1F86", x"FF9C624E", x"FFA6699C", 
      x"FFBA8688", x"FFD6ECAB", x"FFF8D929", x"001CD5B8", x"003F117A", 
      x"005BC6DD", x"006FA427", x"00782B75", x"0073FF9B", x"006314E4", 
      x"0046BF71", x"00219C4F", x"FFF75664", x"FFCC4BFD", x"FFA51DA5", 
      x"FF863153", x"FF7336EE", x"FF6EBB62", x"FF79D674", x"FF93FD40", 
      x"FFBAFFA1", x"FFEB3298", x"001FC4FE", x"0053373D", x"007FEABE", 
      x"00A0BADA", x"00B18F6B", x"00AFD928", x"009AE9A5", x"00741C1D", 
      x"003EC885", x"00000000", x"FFBE174F", x"FF800960", x"FF4CC0C9", 
      x"FF2A5A24", x"FF1D72EF", x"FF289818", x"FF4BE4F2", x"FF84DF17", 
      x"FFCE95FD", x"0022064F", x"0076BA43", x"00C39956", x"00FFD489", 
      x"0123D852", x"012A2BA9", x"01102470", x"00D65C7C", x"0080D7D5", 
      x"0016D3DC", x"FFA23F5B", x"FF2EE3EF", x"FEC9519E", x"FE7DA411", 
      x"FE563E11", x"FE5A9A02", x"FE8E4DD2", x"FEF05D2F", x"FF7AEEE8", 
      x"002371E0", x"00DB343F", x"01906506", x"022F6E21", x"02A48C21", 
      x"02DD823F", x"02CB454F", x"026377E0", x"01A1946E", x"0087A8BF", 
      x"FF1E8E4F", x"FD759666", x"FBA1AC98", x"F9BBFE13", x"F7E03F4A", 
      x"F62AB22F", x"F4B6154B", x"F399A68B", x"F2E76375", x"72AAA11B"
      )
   );
begin
   RamWriter : process (clock, reset)
   begin
      if (reset = '1') then
         firstWrite <= (others => '0');
         arrayCnt <= (others => '0');
         wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
         writeCoeffs <= '1';
      elsif rising_edge(clock) then
         if writeCoeffs = '1' then
            wAddrCnt <= wAddrCnt + n;
            addressB <= std_ulogic_vector(wAddrCnt);
            writeEnB <= '1';
            enB <= '1';
            if arrayCnt <= HALF_FILTER_TAP_NB - 1 then
               if firstWrite = 0 then
                  firstWrite <= firstWrite + 1;
                  dataInB <= std_ulogic_vector(unsigned(coeff(1, to_integer(arrayCnt))
                  (COEFF_BIT_NB - 1 downto (COEFF_BIT_NB - (COEFF_BIT_NB/2)))));
               end if;
               if firstWrite = 1 then
                  firstWrite <= firstWrite + 1;
                  dataInB <= std_ulogic_vector(unsigned(coeff(1, to_integer(arrayCnt))
                     ((COEFF_BIT_NB - (COEFF_BIT_NB/2) - 1) downto 0)));
               end if;
               if firstWrite = 2 then
                  firstWrite <= firstWrite + 1;
                  dataInB <= std_ulogic_vector(unsigned(coeff(0, to_integer(arrayCnt))
                  (COEFF_BIT_NB - 1 downto (COEFF_BIT_NB - (COEFF_BIT_NB/2)))));
               end if;
               if firstWrite = 3 then
                  arrayCnt <= arrayCnt + 1;
                  firstWrite <= (others => '0');
                  dataInB <= std_ulogic_vector(unsigned(coeff(0, to_integer(arrayCnt))
                  ((COEFF_BIT_NB - (COEFF_BIT_NB/2) - 1) downto 0)));
               end if;
            end if;
            if arrayCnt = HALF_FILTER_TAP_NB and firstWrite = 0 then
               writeCoeffs <= '0';
               enB <= '0';
               writeEnB <= '0';
               wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
            end if;
         end if;
      end if;
   end process RamWriter;  
END ARCHITECTURE Archi1;



-- VHDL Entity Splitter.Xover_with_RAM.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 13:55:10 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY Xover_with_RAM IS
    GENERIC( 
        DATA_WIDTH    : positive;
        COEFF_BIT_NB  : positive;
        dataBitNb     : positive;
        addressBitNb  : positive;
        FILTER_TAP_NB : positive
    );
    PORT( 
        DataInCoeffs : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        audio_In     : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock        : IN     std_ulogic;
        dout1        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        filterTapNb  : IN     integer RANGE 999 DOWNTO 0;
        newSample    : IN     std_logic;
        reset        : IN     std_ulogic;
        DataReady    : OUT    std_ulogic;
        DebugData    : OUT    unsigned (1 DOWNTO 0);
        din          : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        highPass     : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass      : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        rdaddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re           : OUT    std_ulogic;
        we           : OUT    std_ulogic;
        wraddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        writeEnA     : OUT    std_ulogic
    );

-- Declarations

END Xover_with_RAM ;






ARCHITECTURE symetrical_reading_SR OF Xover_with_RAM IS
   -- constants
   constant n : positive := 1;
   constant initialWAddress : natural := 0;
   constant initialCoeffAddress : natural := 1501;
   signal HALF_FILTER_TAP_NB : positive := filterTapNb/2 +
   (filterTapNb mod 2);
   constant FINAL_SHIFT : positive := requiredBitNb(FILTER_TAP_NB);
   constant ACCUMULATOR_Bit_NB : positive := COEFF_BIT_NB + audio_In'LENGTH + 
   FINAL_SHIFT;
   signal RAMLength : positive := (((filterTapNb * n * 2) +
   initialWAddress) - 1);


   signal debug0 : std_ulogic;
   signal debug1 : std_ulogic;
   signal calculate : std_ulogic; 
   signal calculatedelayed : std_ulogic;
   -- RAM oriented variables ---------------------------------------------------
   signal firstWrite : std_ulogic;
   signal cntNooffset : unsigned(dataBitNb downto 0);
   signal wAddrCnt : unsigned(addressBitNb - 1 downto 0);
   signal coeffAddr : unsigned(addressBitNb - 1 downto 0);
   signal rAddrCnt_Plus : unsigned(addressBitNb - 1 downto 0);
   signal rAddrCnt_Minus : unsigned(addressBitNb - 1 downto 0);
   signal initialRAddress : unsigned(addressBitNb - 1 downto 0);
   signal RAMfull : std_ulogic;
   signal convertsionPoint : std_ulogic;
   signal convertsionPointDelayed : std_ulogic;
   signal sample1L : signed ((audio_In'length/2 )-1 downto 0);
   signal sample1H : signed ((audio_In'length/2 )-1 downto 0);
   signal sample2H : signed ((audio_In'length/2 )-1 downto 0);
   signal sample2L : signed ((audio_In'length/2 )-1 downto 0); 
   signal coeff1L : signed ((audio_In'length/2 )-1 downto 0);
   signal coeff1H : signed ((audio_In'length/2 )-1 downto 0);
   signal coeff2H : signed ((audio_In'length/2 )-1 downto 0);
   signal coeff2L : signed ((audio_In'length/2 )-1 downto 0);
   signal sample1 : signed (audio_In'range);
   signal sample2 : signed (audio_In'range);
   signal HCoeff : signed (audio_In'range);
   signal LCoeff : signed (audio_In'range);
   
   
BEGIN
   shiftSamplesAndMul : process (clock, reset)
      variable AccumulaorHP : signed (ACCUMULATOR_Bit_NB - 1 downto 0);
      variable AccumulaorLP : signed (ACCUMULATOR_Bit_NB - 1 downto 0);
   begin
      if (reset = '1') then
         calculate <=  '0';
         calculatedelayed <= '0';
         wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
         coeffAddr <= to_unsigned(initialCoeffAddress, wAddrCnt'length);
         firstWrite <= '0';
         rdaddr <= (others => '0');
         RAMfull <= '0';
         convertsionPoint <= '0';
         convertsionPointDelayed <= '0';
         cntNooffset <= (others => '0');
      elsif rising_edge(clock)  then
         RAMLength <= (((filterTapNb * n * 2) + initialWAddress) - 1);
         HALF_FILTER_TAP_NB <= filterTapNb/2 + (filterTapNb mod 2);
         convertsionPointDelayed <= convertsionPoint;
         writeEnA <= '0';
         we <= '1';
         if newSample = '1' then
            firstWrite <= '1';
            -- writing the samples in the RAM
            if ((wAddrCnt + (2 * n) - initialWAddress)) >= RAMLength then
               initialRAddress <= to_unsigned(initialWAddress, initialRAddress'length);
            else
               initialRAddress <= ((wAddrCnt + (2 * n) - initialWAddress));
            end if;
            wAddrCnt <= wAddrCnt + n;
            writeEnA <= '1';
            din <= std_ulogic_vector(unsigned(audio_In(audio_In'LENGTH - 1 downto (audio_In'LENGTH - (audio_In'length/2)))));
            wraddr <= std_ulogic_vector(wAddrCnt);
         end if;
         if firstWrite = '1' then
            calculate <= '1';
            cntNooffset <= (others => '0');
            firstWrite <= '0';
            wAddrCnt <= wAddrCnt + n;
            rAddrCnt_Plus <= initialRAddress;
            rAddrCnt_Minus <= initialRAddress-1;
            wraddr <= std_ulogic_vector(initialRAddress);
            if wAddrCnt >= RAMLength then
               RAMfull <= '1';
               wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
            end if;
            writeEnA <= '1';
            din <= std_ulogic_vector(unsigned(audio_In((audio_In'LENGTH - (audio_In'length/2) - 1) downto 0)));
            wraddr <= std_ulogic_vector(wAddrCnt);
         end if;
         calculatedelayed <= calculate;
        
         coeffAddr <= to_unsigned(initialCoeffAddress, coeffAddr'length);


         if calculatedelayed = '1' and RAMfull = '1' then
            re <= '0';
          
            if convertsionPointDelayed = '1' then
            
               -- updating the Highpass and Lowpass outpout
               Highpass <= resize(shift_right(AccumulaorHP, ACCUMULATOR_Bit_NB - 
               Highpass'LENGTH - 10), Highpass'length);
               LowPass<= resize(shift_right(AccumulaorLP, ACCUMULATOR_Bit_NB -
               LowPass'LENGTH - 10), LowPass'length);
            
            
               -- reseting everything 
               convertsionPoint <= '0';
               convertsionPointDelayed <= '0';
               calculate <= '0';
               coeffAddr <= to_unsigned(initialCoeffAddress, coeffAddr'length);
               cntNooffset <= (others => '0');
               AccumulaorHP := (others => '0');
               AccumulaorLP := (others => '0');
               
               
            else
               cntNooffset <= cntNooffset + 1;
            end if;
            
            -- coeff adress update and incement 
            rdaddr <= std_ulogic_vector(coeffAddr);
            coeffAddr <= coeffAddr + 1;
           
           
            debug0 <= '0';
            debug1 <= '0';
            
            if cntNooffset mod 4 = 0 then 
               debug0 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               sample2(sample2'LENGTH - 1 downto (sample2'LENGTH - (sample2'length/2))) <= sample2H;
               sample2((sample2'LENGTH - (sample2'length/2) - 1) downto 0) <= sample2L;
               
               -- positive sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Plus);
               rAddrCnt_Plus <= rAddrCnt_Plus + 1;
               
               -- saving the RAM value to create the full data 
               sample1L <= signed(dout1);
               coeff1L <=  signed(DataInCoeffs); 
            elsif cntNooffset mod 4 = 1 then 
               debug0 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               HCoeff(HCoeff'LENGTH - 1 downto (HCoeff'LENGTH - (HCoeff'length/2))) <= coeff1H;
               HCoeff((HCoeff'LENGTH - (HCoeff'length/2) - 1) downto 0) <= coeff1L;
               
               -- positive sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Plus);
               rAddrCnt_Plus <= rAddrCnt_Plus + 1;
               
               -- saving the RAM value to create the full data 
               sample1H <= signed(dout1);
               coeff2H <=  signed(DataInCoeffs);
            elsif cntNooffset mod 4 = 2 then 
               debug1 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               sample1(sample1'LENGTH - 1 downto (sample1'LENGTH - (sample1'length/2))) <= sample1H;
               sample1((sample1'LENGTH - (sample1'length/2) - 1) downto 0) <= sample1L;
               
               -- negative sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Minus);
               rAddrCnt_Minus <= rAddrCnt_Minus - 1;
               
               -- saving the RAM value to create the full data 
               sample2H <= signed(dout1);
               coeff2L <=  signed(DataInCoeffs);
            elsif cntNooffset mod 4 = 3 then 
               debug1 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               LCoeff(LCoeff'LENGTH - 1 downto (LCoeff'LENGTH - (LCoeff'length/2))) <= coeff2H;
               LCoeff((LCoeff'LENGTH - (LCoeff'length/2) - 1) downto 0) <= coeff2L;
              
               -- negative sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Minus);
               rAddrCnt_Minus <= rAddrCnt_Minus - 1;
               
               -- saving the RAM value to create the full data 
               coeff1H <=  signed(DataInCoeffs);
               sample2L <= signed(dout1);
            end if;
            -- if we go past the ram length we need 
            if rAddrCnt_Plus >= RAMLength then
               -- reset the counter to intial adress
               rAddrCnt_Plus <= to_unsigned(initialWAddress, wAddrCnt'length);
            end if;
            -- if we go past the ram length we need 
            if rAddrCnt_Minus-1 > RAMLength then
               -- reset the counter to the final adress
              
               rAddrCnt_Minus <= to_unsigned(RAMLength, rAddrCnt_Plus'length);
            end if;
          
            
            -- if the conversion point is reached 
            if cntNooffset = (filterTapNb * n * 2 ) + 5 then
               convertsionPoint <= '1';
               -- updates the accumulator with only one sample because
               -- sample1 = sample2 at the conversion Point 
               AccumulaorHP := AccumulaorHP + sample1 * HCoeff;
               AccumulaorLP := AccumulaorLP + sample1 * LCoeff;
            elsif cntNooffset >= 7 and (cntNooffset mod 4) = 0 
            and cntNooffset <= (filterTapNb * n * 2 )+ 3 then
               -- updates the accumulators
               AccumulaorHP := AccumulaorHP + (resize(sample1, sample1'LENGTH + 1) + sample2) * HCoeff;
               AccumulaorLP := AccumulaorLP + (resize(sample1, sample1'LENGTH + 1) + sample2) * LCoeff;
            end if;

         end if;
      end if;
   end process shiftSamplesAndMul;
   
   DataReady <= '1' when calculate = '0' else '0';
   DebugData(1) <= convertsionPoint;
   DebugData(0) <= newSample;
   
END ARCHITECTURE symetrical_reading_SR;



-- VHDL Entity Splitter.MuxRAM.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 13:26:50 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY MuxRAM IS
    GENERIC( 
        dataBitNb    : positive;
        addressBitNb : positive
    );
    PORT( 
        addressB   : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        addressBRs : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB    : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataInBRs  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB1       : IN     std_ulogic;
        outputEn   : IN     std_ulogic;
        rdaddr     : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re         : IN     std_ulogic;
        writeEnB   : IN     std_ulogic;
        writeEnRs  : IN     std_ulogic;
        addressB1  : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB1   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB        : OUT    std_ulogic;
        writeEnB1  : OUT    std_ulogic
    );

-- Declarations

END MuxRAM ;





--
-- VHDL Architecture Splitter.MuxRAM.WithRS232
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:21:26 04.08.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE WithRS232 OF MuxRAM IS

   signal tempData : std_ulogic_vector(dataBitNb-1 downto 0);
   signal tempAddress : std_ulogic_vector(addressBitNb-1 downto 0);
   signal tempWriteEn : std_ulogic;
   
BEGIN
   enB <= '1';
   
   tempData <= dataInB when enB1 = '1' else dataInBRs;
   tempWriteEn <= writeEnB when enB1 = '1' else writeEnRs;
   tempAddress <= addressB when enB1 = '1' else addressBRs;
   
   dataInB1 <= tempData when (enB1 = '1' or outputEn = '1') else dataInB;
   writeEnB1 <= tempWriteEn when (enB1 = '1' or outputEn = '1') else re;
   addressB1 <= tempAddress when (enB1 = '1' or outputEn = '1') else rdaddr;
   
END ARCHITECTURE WithRS232;





-- VHDL Entity Splitter.RS232_reciver.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:10:35 02.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY RS232_reciver IS
    GENERIC( 
        uartDataBitNb  : positive;
        baudRateDivide : positive
    );
    PORT( 
        RxD        : IN     std_ulogic;
        clock      : IN     std_ulogic;
        reset      : IN     std_ulogic;
        RS232Data  : OUT    std_ulogic_vector (uartDataBitNb-1 DOWNTO 0);
        RS232Valid : OUT    std_ulogic;
        debug0     : OUT    std_ulogic
    );

-- Declarations

END RS232_reciver ;





--
-- VHDL Architecture Splitter.RS232_reciver.FromMorse_Labo5
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:18:31 02.08.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
library Common;
use Common.CommonLib.all;

ARCHITECTURE FromMorse_Labo5 OF RS232_reciver IS
   signal dividerCounter: unsigned(requiredBitNb(baudRateDivide-1)-1 downto 0);
   signal dividerCounterReset: std_uLogic;
   signal rxDelayed: std_uLogic;
   signal dividerCounterSynchronize: std_uLogic;
   signal rxSample: std_uLogic;
   signal rxShiftReg: std_ulogic_vector(uartDataBitNb-1 downto 0);
   signal rxReceiving: std_uLogic;
   signal rxDataValid: std_uLogic;
   signal rxCounter: unsigned(requiredBitNb(uartDataBitNb)-1 downto 0);

begin

   divide: process(reset, clock)
   begin
      if reset = '1' then
         dividerCounter <= (others => '0');
      elsif rising_edge(clock) then
         if dividerCounterSynchronize = '1' then
            dividerCounter <= to_unsigned(baudRateDivide/2, dividerCounter'length);
         elsif dividerCounterReset = '1' then
            dividerCounter <= (others => '0');
         else
            dividerCounter <= dividerCounter + 1;
         end if;
      end if;
   end process divide;

   endOfCount: process(dividerCounter)
   begin
      if dividerCounter = baudRateDivide-1 then
         dividerCounterReset <= '1';
         
      else
         dividerCounterReset <= '0';
         
      end if;
   end process endOfCount;

   delayRx: process(reset, clock)
   begin
      if reset = '1' then
         rxDelayed <= '0';
      elsif rising_edge(clock) then
         rxDelayed <= RxD;
      end if;
   end process delayRx;

   rxSynchronize: process(RxD, rxDelayed)
   begin
      if RxD /= rxDelayed then
         dividerCounterSynchronize <= '1';
      else
         dividerCounterSynchronize <= '0';
      end if;
   end process rxSynchronize;

   rxSample <= dividerCounterReset;

   shiftReg: process(reset, clock)
   begin
      if reset = '1' then
         rxShiftReg <= (others => '0');
      elsif rising_edge(clock) then
         if rxSample = '1' then
            rxShiftReg(rxShiftReg'high-1 downto 0) <= rxShiftReg(rxShiftReg'high downto 1);
            rxShiftReg(rxShiftReg'high) <= RxD;
         end if;
      end if;
   end process shiftReg;

   detectReceive: process(reset, clock)
   begin
      if reset = '1' then
         rxReceiving <= '0';
         rxDataValid <= '0';
      elsif rising_edge(clock) then
         if rxSample = '1' then
            if rxCounter = uartDataBitNb-1 then
               rxDataValid <= '1';
            elsif RxD = '0' then
               rxReceiving <= '1';
            end if;
         elsif rxDataValid = '1' then
            rxReceiving <= '0';
            rxDataValid <= '0';
         end if;
      end if;
   end process detectReceive;

   countRxBitNb: process(reset, clock)
   begin
      if reset = '1' then
         rxCounter <= (others => '0');
      elsif rising_edge(clock) then
         
         if rxSample = '1' then
            if rxReceiving = '1' then
            rxCounter <= rxCounter + 1;
            debug0 <= '1';
            else
            rxCounter <= (others => '0'); 
            debug0 <= '0';
            end if;
         end if;
      end if;
   end process countRxBitNb;

   RS232Data <= rxShiftReg;
   RS232Valid <= rxDataValid;

END ARCHITECTURE FromMorse_Labo5;





-- VHDL Entity Splitter.testerRS232.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 13:54:49 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY testerRS232 IS
    GENERIC( 
        uartDataBitNb : positive;
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive
    );
    PORT( 
        RS232Data   : IN     std_ulogic_vector (uartDataBitNb -1 DOWNTO 0);
        RS232Valid  : IN     std_ulogic;
        clock       : IN     std_ulogic;
        reset       : IN     std_ulogic;
        FilterTapNb : OUT    integer RANGE 999 DOWNTO 0;
        NewCoeff    : OUT    std_ulogic;
        RS232Coeff  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        outputEn    : OUT    std_ulogic
    );

-- Declarations

END testerRS232 ;





--
-- VHDL Architecture Splitter.testerRS232.RS232_test1
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:43:22 02.08.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--

   ARCHITECTURE RS232_test1 OF testerRS232 IS
   signal debuggg : std_ulogic;
   
   signal isA, isB, isC, isD, isE, isF, isG, isH,
         isI, isJ, isK, isL, isM, isN, isO, isP,
         isQ, isR, isS, isT, isU, isV, isW, isX,
         isY, isZ,
         is0, is1, is2, is3, is4, is5, is6, is7,
         is8, is9, 
         isSpace,isExcla,isHashTag : std_ulogic;
   TYPE STATEL_TYPE IS (           --State enum for SM LEFT
    
      state_idle,
      state_test0,
      state_test1,
      state_test2,
      state_coeffNb,
      state_startCoeff,
      state_newCoeff
      
  );
  
  signal cnt : unsigned(7 downto 0);
  signal cnt1 : unsigned(7 downto 0);
  signal coeffCnt : unsigned(31 downto 0);
  signal currentState : STATEL_TYPE;
  signal temp0 : unsigned(3 downto 0);
  signal coeff0 : unsigned(31 downto 0);
  signal temp1 : unsigned(3 downto 0);
  signal coeffNb : unsigned(31 downto 0);
  signal outputEnDriver : std_ulogic;
BEGIN

    ------------------------------------------------------------------------------
                                                   -- conditions for morse units
  isA <= '1' when std_match(unsigned(RS232Data), "1-0" & x"1") else '0';
  isB <= '1' when std_match(unsigned(RS232Data), "1-0" & x"2") else '0';
  isC <= '1' when std_match(unsigned(RS232Data), "1-0" & x"3") else '0';
  isD <= '1' when std_match(unsigned(RS232Data), "1-0" & x"4") else '0';
  isE <= '1' when std_match(unsigned(RS232Data), "1-0" & x"5") else '0';
  isF <= '1' when std_match(unsigned(RS232Data), "1-0" & x"6") else '0';
  isG <= '1' when std_match(unsigned(RS232Data), "1-0" & x"7") else '0';
  isH <= '1' when std_match(unsigned(RS232Data), "1-0" & x"8") else '0';
  isI <= '1' when std_match(unsigned(RS232Data), "1-0" & x"9") else '0';
  isJ <= '1' when std_match(unsigned(RS232Data), "1-0" & x"A") else '0';
  isK <= '1' when std_match(unsigned(RS232Data), "1-0" & x"B") else '0';
  isL <= '1' when std_match(unsigned(RS232Data), "1-0" & x"C") else '0';
  isM <= '1' when std_match(unsigned(RS232Data), "1-0" & x"D") else '0';
  isN <= '1' when std_match(unsigned(RS232Data), "1-0" & x"E") else '0';
  isO <= '1' when std_match(unsigned(RS232Data), "1-0" & x"F") else '0';
  isP <= '1' when std_match(unsigned(RS232Data), "1-1" & x"0") else '0';
  isQ <= '1' when std_match(unsigned(RS232Data), "1-1" & x"1") else '0';
  isR <= '1' when std_match(unsigned(RS232Data), "1-1" & x"2") else '0';
  isS <= '1' when std_match(unsigned(RS232Data), "1-1" & x"3") else '0';
  isT <= '1' when std_match(unsigned(RS232Data), "1-1" & x"4") else '0';
  isU <= '1' when std_match(unsigned(RS232Data), "1-1" & x"5") else '0';
  isV <= '1' when std_match(unsigned(RS232Data), "1-1" & x"6") else '0';
  isW <= '1' when std_match(unsigned(RS232Data), "1-1" & x"7") else '0';
  isX <= '1' when std_match(unsigned(RS232Data), "1-1" & x"8") else '0';
  isY <= '1' when std_match(unsigned(RS232Data), "1-1" & x"9") else '0';
  isZ <= '1' when std_match(unsigned(RS232Data), "1-1" & x"A") else '0';
  is0 <= '1' when std_match(unsigned(RS232Data), "011" & x"0") else '0';
  is1 <= '1' when std_match(unsigned(RS232Data), "011" & x"1") else '0';
  is2 <= '1' when std_match(unsigned(RS232Data), "011" & x"2") else '0';
  is3 <= '1' when std_match(unsigned(RS232Data), "011" & x"3") else '0';
  is4 <= '1' when std_match(unsigned(RS232Data), "011" & x"4") else '0';
  is5 <= '1' when std_match(unsigned(RS232Data), "011" & x"5") else '0';
  is6 <= '1' when std_match(unsigned(RS232Data), "011" & x"6") else '0';
  is7 <= '1' when std_match(unsigned(RS232Data), "011" & x"7") else '0';
  is8 <= '1' when std_match(unsigned(RS232Data), "011" & x"8") else '0';
  is9 <= '1' when std_match(unsigned(RS232Data), "011" & x"9") else '0';
  isSpace <= '1' when std_match(unsigned(RS232Data), "010" & x"0") else '0';
  isExcla <= '1' when std_match(unsigned(RS232Data), "010" & x"1") else '0';
  isHashTag <= '1' when std_match(unsigned(RS232Data), "010" & x"3") else '0';
  
    
   
   testter : process(clock,reset)
   begin 
      if reset = '1' then
       
         currentState <= state_idle;
         cnt <= (others => '0');
         cnt1 <= (others => '0');
         Coeffcnt <= (others => '0');
         coeff0 <= (others => '0');
         coeffNb <= (others => '0');
         filterTapNb <= FILTER_TAP_NB;
         outputEn <= '0';
         outputEnDriver <= '0';
      elsif rising_edge(clock) then
         newCoeff <= '0';
       
         if RS232Valid = '1' then 
            -- Idle State 
            if currentState = state_idle and isN = '1' then 
               currentState <= state_test0;
            end if;
            
            if currentState = state_test0 and isE = '1' then 
               currentState <= state_test1;
            end if;
            if currentState = state_test1 and isW = '1' then 
               currentState <= state_CoeffNb;
               cnt1 <= (others => '0');
               coeffCnt <= (others => '0');
            end if;
            if currentState = state_CoeffNb then 
               
               cnt1 <= cnt1 + 1;
               if is0  = '1'     then temp1 <= to_unsigned(0,temp1'length);
               elsif is1 = '1'   then temp1 <= to_unsigned(1,temp1'length);
               elsif is2 = '1'   then temp1 <= to_unsigned(2,temp1'length);
               elsif is3 = '1'   then temp1 <= to_unsigned(3,temp1'length);
               elsif is4 = '1'   then temp1 <= to_unsigned(4,temp1'length);
               elsif is5 = '1'   then temp1 <= to_unsigned(5,temp1'length);
               elsif is6 = '1'   then temp1 <= to_unsigned(6,temp1'length);
               elsif is7 = '1'   then temp1 <= to_unsigned(7,temp1'length);
               elsif is8  = '1'  then temp1 <= to_unsigned(8,temp1'length); 
               elsif is9 = '1'   then temp1 <= to_unsigned(9,temp1'length);
               elsif isA = '1'   then temp1 <= to_unsigned(10,temp1'length);
               elsif isB = '1'   then temp1 <= to_unsigned(11,temp1'length);
               elsif isC = '1'   then temp1 <= to_unsigned(12,temp1'length);
               elsif isD = '1'   then temp1 <= to_unsigned(13,temp1'length);
               elsif isE = '1'   then temp1 <= to_unsigned(14,temp1'length);
               elsif isF = '1'   then temp1 <= to_unsigned(15,temp1'length);
               -- condition to do out of the newCoeff state 
               elsif isT = '1'  then 
                  currentState <= state_startCoeff;
                  outputEnDriver <= '1';
               end if;
               
               
               
               if cnt1 /= 0 and cnt1 <=4 then 
                 
                  if cnt1 = 1 then coeffNb(15 downto 12) <= temp1;
                  elsif cnt1 = 2 then coeffNb(11 downto 8) <= temp1;
                  elsif cnt1 = 3 then coeffNb(7 downto 4) <= temp1;
                  elsif cnt1 = 4 then coeffNb(3 downto 0) <= temp1;
                  end if;
                  -- coeff0(to_integer((8-(cnt-1)*4)-1) downto 
                  -- to_integer((8-cnt)*4)) <= temp0;
               end if; 
            end if;
         
            
            if currentState = state_startCoeff and isX = '1' then 
               
               if coeffcnt > coeffNb then
                  currentState <= state_idle;
                  coeffCnt <= (others => '0');
                  outputEnDriver <= '0';
               else
                  filterTapNb <= to_integer(coeffNb);
                  if coeffCnt /= 0 then 
                     RS232Coeff <= signed(coeff0); 
                     newCoeff <= '1';
                  end if;
                  currentState <= state_test2;
               end if;
              
            end if;
            -- test if we are reciving a new coefff
            if currentState = state_test2 and isExcla = '1' then
               currentState <= state_newCoeff;
               coeffCnt <= coeffCnt + 1;
               cnt <= (others => '0');
            end if;
            -- translating ascii values to hex(32 bits)
            if currentState = state_newCoeff then 
               
               cnt <= cnt + 1;
               if is0  = '1'     then temp0 <= to_unsigned(0,temp0'length);
               elsif is1 = '1'   then temp0 <= to_unsigned(1,temp0'length);
               elsif is2 = '1'   then temp0 <= to_unsigned(2,temp0'length);
               elsif is3 = '1'   then temp0 <= to_unsigned(3,temp0'length);
               elsif is4 = '1'   then temp0 <= to_unsigned(4,temp0'length);
               elsif is5 = '1'   then temp0 <= to_unsigned(5,temp0'length);
               elsif is6 = '1'   then temp0 <= to_unsigned(6,temp0'length);
               elsif is7 = '1'   then temp0 <= to_unsigned(7,temp0'length);
               elsif is8  = '1'  then temp0 <= to_unsigned(8,temp0'length); 
               elsif is9 = '1'   then temp0 <= to_unsigned(9,temp0'length);
               elsif isA = '1'   then temp0 <= to_unsigned(10,temp0'length);
               elsif isB = '1'   then temp0 <= to_unsigned(11,temp0'length);
               elsif isC = '1'   then temp0 <= to_unsigned(12,temp0'length);
               elsif isD = '1'   then temp0 <= to_unsigned(13,temp0'length);
               elsif isE = '1'   then temp0 <= to_unsigned(14,temp0'length);
               elsif isF = '1'   then temp0 <= to_unsigned(15,temp0'length);
               -- condition to do out of the newCoeff state 
               elsif isExcla = '1'  then 
                  currentState <= state_startCoeff;
               end if;
               
               
               if cnt /= 0 and cnt <=8 then 
                 
                  
                  if cnt = 1 then coeff0(31 downto 28) <= temp0;
                  elsif cnt = 2 then coeff0(27 downto 24) <= temp0;
                  elsif cnt = 3 then coeff0(23 downto 20) <= temp0;
                  elsif cnt = 4 then coeff0(19 downto 16) <= temp0;
                  elsif cnt = 5 then coeff0(15 downto 12) <= temp0;
                  elsif cnt = 6 then coeff0(11 downto 8) <= temp0;
                  elsif cnt = 7 then coeff0(7 downto 4) <= temp0;
                  elsif cnt = 8 then coeff0(3 downto 0) <= temp0;
                  end if;
                  
                  -- coeff0(to_integer((8-(cnt-1)*4)-1) downto 
                  -- to_integer((8-cnt)*4)) <= temp0;
               end if; 
            end if;
         end if;  
         
         outputEn <= outputEnDriver;
         
      end if; 
   end process testter;

END ARCHITECTURE RS232_test1;





-- VHDL Entity Splitter.Rs232ToRam.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 13:59:00 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY Rs232ToRam IS
    GENERIC( 
        dataBitNb    : integer;
        DATA_WIDTH   : integer;
        addressBitNb : integer
    );
    PORT( 
        NewCoeff   : IN     std_ulogic;
        RS232Coeff : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock      : IN     std_ulogic;
        outputEn   : IN     std_ulogic;
        reset      : IN     std_ulogic;
        addressBRs : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInBRs  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        writeEnRs  : OUT    std_ulogic
    );

-- Declarations

END Rs232ToRam ;





--
-- VHDL Architecture Splitter.Rs232ToRam.a16BitArchi
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:18:58 04.08.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE a16BitArchi OF Rs232ToRam IS
  
   signal firstWrite : unsigned(3 downto 0);
   signal wAddrCnt : unsigned(addressBitNb - 1 downto 0);
   signal arrayCnt : unsigned(addressBitNb - 1 downto 0);
   signal writeCoeffs : std_ulogic;

   constant n : positive := 1;
   constant initialWAddress : integer := 1502;
   
  
begin
   RamWriter : process (clock, reset)
   begin
      if (reset = '1') then
         firstWrite <= (others => '0');
         arrayCnt <= (others => '0');
         wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
         writeCoeffs <= '1';
         dataInBRs<= (others => '0');
         addressBRs<= (others => '0');
         writeEnRs <= '0';
      elsif rising_edge(clock) then
         if outputEn = '0' then 
            writeCoeffs <= '0';
            writeEnRs <= '0';
            wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
         else
            if newCoeff = '1' or firstWrite /= 0 then
               wAddrCnt <= wAddrCnt + n;
               addressBRs <= std_ulogic_vector(wAddrCnt);
               writeEnRs <= '1';
              
              
                  if firstWrite = 0 then
                     firstWrite <= firstWrite + 1;
                     dataInBRs <= std_ulogic_vector(unsigned(RS232Coeff
                     (RS232Coeff'length - 1 downto (RS232Coeff'length - (RS232Coeff'length/2)))));
                  end if;
                  if firstWrite = 1 then
                     firstWrite <= (others => '0');
                     dataInBRs <= std_ulogic_vector(unsigned(RS232Coeff
                     ((RS232Coeff'length - (RS232Coeff'length/2) - 1) downto 0)));
                  end if;
            end if;
         end if;
      end if;
   end process RamWriter;  
END ARCHITECTURE a16BitArchi;





-- VHDL Entity Splitter.iisEncoder.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:32:16 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;  
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY iisEncoder IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        reset      : IN     std_ulogic;
        clock      : IN     std_ulogic;
        audioLeft  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        LRCK       : OUT    std_ulogic;
        SCK        : OUT    std_ulogic;
        DOUT       : OUT    std_ulogic;
        CLKI2s     : IN     std_uLogic;
        LRCK1      : IN     std_uLogic;
        NewData    : OUT    std_uLogic;
        Frameout0  : OUT    std_uLogic
    );

-- Declarations

END iisEncoder ;






ARCHITECTURE inputLRCK OF iisEncoder IS
   
   constant frameLength : positive := audioLeft'length;
   constant frameCounterBitNb : positive := requiredBitNb(frameLength - 1);

   signal lrckDelayed, lrckChanged : std_ulogic;
   signal sckDelayed, sckRising, sckFalling : std_ulogic;
   signal frameCounter : unsigned(frameCounterBitNb - 1 downto 0);
   signal frameCounterDelayed : unsigned(frameCounterBitNb - 1 downto 0);
   signal LRDelayed : std_uLogic;
   signal leftShiftRegister : signed(audioLeft'range);
   signal rightShiftRegister : signed(audioRight'range);

BEGIN
   delaySck : process (reset, clock)
   begin
      if reset = '1' then
         sckDelayed <= '0';
         lrckDelayed <= '0';
      elsif rising_edge(clock) then
         -- 1 clock period delay to detect the edges
         sckDelayed <= CLKI2s;
         lrckDelayed <= LRCK1;
      end if;
   end process delaySck;
    -- edges detection
   sckRising <= '1' when (CLKI2s = '1') and (sckDelayed = '0') else '0';
   sckFalling <= '1' when (CLKI2s = '0') and (sckDelayed = '1') else '0';
   lrckChanged <= '1' when LRCK1 /= lrckDelayed else '0';
   
   FlipFlopAndResize : process (reset, clock)
   begin
      if reset = '1' then
         frameCounter <= (others => '0');
         frameCounterDelayed <= (others => '0');
         leftShiftRegister <= (others => '0');
         rightShiftRegister <= (others => '0');
         LRDelayed <= '0';
      elsif rising_edge(clock) then
         NewData <= '0';
         if sckRising = '1' then
            -- decrementing frame counter
            frameCounter <= frameCounter - 1;
             -- delaying frameCounter
            frameCounterDelayed <= frameCounter;
            -- delaying LR
            LRDelayed <= LRCK1;
         
         elsif sckFalling = '1' then
          -- updating DOUT at the flaaing edge
            if LRDelayed = '0' then
               DOUT <= leftShiftRegister(to_integer(frameCounterDelayed));
            else
               DOUT <= rightShiftRegister(to_integer(frameCounterDelayed));
            end if;
         end if;

         if lrckChanged = '1' then
            -- reseting the frame counter for every new communication
            frameCounter <= (others => '1');
         end if;
         -- asking for the new data at the msb-2 to delete every posiblity of
         -- transition issues (the 3 lasts bits of every data is '0')      
         if frameCounter = 3 and LRDelayed = '1' and CLKI2s = '0' then
            NewData <= '1';
         end if;
         if frameCounter = 3 and LRDelayed = '1' and CLKI2s = '1' then
            -- saving the values to communicate
            rightShiftRegister <= audioRight;
            leftShiftRegister <= audioLeft;
         end if;
         -- updating the outpout
         LRCK <= LRCK1;
         SCK <= CLKI2s;
         -- debug output
         Frameout0 <= frameCounter(0);
      end if;
   end process FlipFlopAndResize;
   
END ARCHITECTURE inputLRCK;



-- VHDL Entity Memory.bramDualport.symbol
--
-- Created:
--          by - maxim.UNKNOWN (DESKTOP-ADLE19A)
--          at - 12:26:57 19/07/2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    USE ieee.numeric_std.all;

ENTITY bramDualport IS
    GENERIC( 
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT( 
        clockA   : IN     std_ulogic;
        enA      : IN     std_ulogic;
        writeEnA : IN     std_ulogic;
        addressA : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInA  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutA : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        clockB   : IN     std_ulogic;
        enB      : IN     std_ulogic;
        writeEnB : IN     std_ulogic;
        addressB : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutB : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END bramDualport ;





USE std.textio.all;

ARCHITECTURE bhv OF bramDualport IS
  -- Define ramContent type
  type ramContentType is array(0 to (2**addressBitNb)-1) of bit_vector(dataBitNb-1 DOWNTO 0);

  -- Declare ramContent signal
  shared variable ramContent: ramContentType;

BEGIN
  -- Port A
  process(clockA)
  begin
    if clockA'event and clockA='1' then
      if enA = '1' then
        if writeEnA = '1' then
          dataOutA <= dataInA;
          ramContent(to_integer(unsigned(addressA))) := to_bitvector(dataInA,'0');
        else
          dataOutA <= to_stdulogicvector(ramContent(to_integer(unsigned(addressA))));
        end if;
      end if;
    end if;
  end process;

  -- Port B
  process(clockB)
  begin
    if clockB'event and clockB='1' then
      if enB = '1' then
        if writeEnB = '1' then
          ramContent(to_integer(unsigned(addressB))) := to_bitvector(dataInB,'0');
          dataOutB <= dataInB;
        else
          dataOutB <= to_stdulogicvector(ramContent(to_integer(unsigned(addressB))));
        end if;
      end if;
    end if;
  end process;

END ARCHITECTURE bhv;




-- VHDL Entity Splitter.SeialSync.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 12:54:43 27.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY SeialSync IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        DataReady   : IN     std_ulogic;
        LR_I        : IN     std_uLogic;
        NewData     : IN     std_uLogic;
        clock       : IN     std_uLogic;
        highPass    : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass     : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        reset       : IN     std_uLogic;
        audioLeft1  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight1 : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );

-- Declarations

END SeialSync ;





--------------------------------------------------------------------------------
-- ensures the syncro between the Xover and the i2s encoder 
-- also devides the highpass signal by 2 to account for the higher 
-- efficency of the tweeter
--------------------------------------------------------------------------------
ARCHITECTURE sync1 OF SeialSync IS
	signal oldR : std_ulogic;
	signal oldLR : std_ulogic;
	signal cnt : unsigned(2 downto 0);
	signal tempLow : signed(lowPass'range);
	signal tempHigh : signed(highPass'range);
BEGIN
	syncro : process (clock, reset)
	begin
		if (reset = '1') then
			oldR <= '0';
			oldLR <= '0';
			cnt <= (others => '0');
			tempHigh <= (others => '0');
			tempLow <= (others => '0');
		elsif rising_edge(clock) then
			if DataReady = '1' then
				tempLow <= lowPass;
				tempHigh <= highPass;
				tempLow(0) <= '0';
				tempLow(1) <= '0';
				tempLow(2) <= '0';
				tempHigh(0) <= '0';
				tempHigh(1) <= '0';
				tempHigh(2) <= '0';
			end if;
			audioRight1 <= tempLow;
			-- to account for the higher efficency of the twitter
			audioLeft1 <= resize(shift_right(tempHigh, 1),audioLeft1'length);
		end if;
	end process syncro;
END ARCHITECTURE sync1;



-- VHDL Entity Splitter.risingEdgeDetector.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:00:47 02.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY risingEdgeDetector IS
    PORT( 
        clock     : IN     std_logic;
        dataValid : IN     std_logic;
        reset     : IN     std_logic;
        en        : OUT    std_logic
    );

-- Declarations

END risingEdgeDetector ;





-------------------------------------------
-- detecting the risingEdge of a sinal
-------------------------------------------
ARCHITECTURE edge OF risingEdgeDetector IS

   signal signalDelayed : std_logic;

BEGIN

   delaySignal : process(clock,reset)
   begin 

   if reset = '1' then
      signalDelayed <= '0';
   elsif rising_edge(clock) then
      -- delaying the signal 
      signalDelayed <= DataValid;
   end if;
end process delaySignal;
   -- detecting the rising dege and updating the output
   en <= '1' when (DataValid = '1') and (signalDelayed = '0') else '0';
   
END ARCHITECTURE edge;





-- VHDL Entity Splitter.muxOut.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:04:42 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY muxOut IS
    PORT( 
        DOUT   : IN     std_ulogic;
        LRCK   : IN     std_ulogic;
        SCK    : IN     std_ulogic;
        en     : IN     std_ulogic;
        CLK_O  : OUT    std_uLogic;
        Data_O : OUT    std_uLogic;
        LR_O   : OUT    std_ulogic
    );

-- Declarations

END muxOut ;





--------------------------------------------------------------------------------
-- multiplexor to switch between the modified data and the raw
--------------------------------------------------------------------------------
ARCHITECTURE TIOrFPGA OF muxOut IS
BEGIN
    Data_O <= DOUT when en = '0' else '0' ;
    LR_O <= LRCK when en = '0' else '0' ;
    CLK_O <= SCK when en = '0' else '0' ;
END ARCHITECTURE TIOrFPGA;





-- VHDL Entity Splitter.delayer.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 14:20:38 03.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

ENTITY delayer IS
    PORT( 
        Data         : IN     std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        Data_delayed : OUT    std_logic
    );

-- Declarations

END delayer ;





-------------------------------------------------------------
-- delaying the signal to take into account the sync register 
-------------------------------------------------------------

ARCHITECTURE delay1 OF delayer IS
BEGIN
    delaySignal : process(clock,reset)
    begin 
       
        if reset = '1' then
			data_delayed <= '0';
		elsif rising_edge(clock) then
            -- delay the siganl by 1 clock period 
           data_delayed <= Data;
        end if;
    end process delaySignal;
    
END ARCHITECTURE delay1;





--
-- VHDL Architecture Splitter.leftRightSplitter.visitorsVersion
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 17:01:31 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

LIBRARY Memory;
LIBRARY Splitter;
LIBRARY Splitter_test;

ARCHITECTURE visitorsVersion OF leftRightSplitter IS

    -- Architecture declarations
    constant DATA_WIDTH : positive := 32;
    constant COEFF_BIT_NB : positive := 32;
    constant FILTER_TAP_NB : positive := 649;
    constant DATA_IN_WIDTH : positive := 32;
    constant addressBitNb :positive := 12;
    constant dataBitNb :positive := 16;
    constant initFile : string := "bramInit.txt";
    constant uartDataBitNb : positive := 7;
    constant uartBaudRate: real := 9.6E3;
    constant clockFrequency: real := 66.0E6;

    -- Internal signal declarations
    SIGNAL DOUT        : std_ulogic;
    SIGNAL Data        : std_ulogic;
    SIGNAL DataReady   : std_ulogic;
    SIGNAL DebugData   : unsigned(1 DOWNTO 0);
    SIGNAL FilterTapNb : integer RANGE 999 DOWNTO 0;
    SIGNAL Frameout0   : std_uLogic;
    SIGNAL LRCK        : std_ulogic;
    SIGNAL NewCoeff    : std_ulogic;
    SIGNAL NewData     : std_uLogic;
    SIGNAL Next_data   : std_ulogic;
    SIGNAL RS232Coeff  : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL RS232Data   : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
    SIGNAL RS232Valid  : std_ulogic;
    SIGNAL SCK         : std_ulogic;
    SIGNAL addressB    : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL addressB1   : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL addressBRs  : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL audioLeft   : signed(DATA_IN_WIDTH-1 DOWNTO 0);
    SIGNAL audioLeft1  : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL audioRight  : signed(DATA_IN_WIDTH-1 DOWNTO 0);
    SIGNAL audioRight1 : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL audio_R_out : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL dataInB     : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataInB1    : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataInBRs   : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataOutA    : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataOutB    : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataValid   : std_ulogic;
    SIGNAL debug0      : std_ulogic;
    SIGNAL din         : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL enB         : std_ulogic;
    SIGNAL enB1        : std_ulogic;
    SIGNAL end_Calc    : std_ulogic;
    SIGNAL highPass    : signed(DATA_WIDTH-1  DOWNTO  0);
    SIGNAL lowPass     : signed(DATA_WIDTH-1  DOWNTO  0);
    SIGNAL newSample   : std_logic;
    SIGNAL outputEn    : std_ulogic;
    SIGNAL rdaddr      : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL re          : std_ulogic;
    SIGNAL we          : std_ulogic;
    SIGNAL wraddr      : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL writeEnA    : std_ulogic;
    SIGNAL writeEnB    : std_ulogic;
    SIGNAL writeEnB1   : std_ulogic;
    SIGNAL writeEnRs   : std_ulogic;


    -- Component Declarations
    COMPONENT bramDualport
    GENERIC (
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT (
        clockA   : IN     std_ulogic ;
        enA      : IN     std_ulogic ;
        writeEnA : IN     std_ulogic ;
        addressA : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInA  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutA : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        clockB   : IN     std_ulogic ;
        enB      : IN     std_ulogic ;
        writeEnB : IN     std_ulogic ;
        addressB : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutB : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT CoeffWriter
    GENERIC (
        addressBitNb  : positive;
        dataBitNb     : positive;
        COEFF_BIT_NB  : positive;
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive
    );
    PORT (
        clock    : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        addressB : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB      : OUT    std_ulogic ;
        writeEnB : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT MuxRAM
    GENERIC (
        dataBitNb    : positive;
        addressBitNb : positive
    );
    PORT (
        addressB   : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        addressBRs : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB    : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataInBRs  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB1       : IN     std_ulogic ;
        outputEn   : IN     std_ulogic ;
        rdaddr     : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re         : IN     std_ulogic ;
        writeEnB   : IN     std_ulogic ;
        writeEnRs  : IN     std_ulogic ;
        addressB1  : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB1   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB        : OUT    std_ulogic ;
        writeEnB1  : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT RS232_reciver
    GENERIC (
        uartDataBitNb  : positive;
        baudRateDivide : positive
    );
    PORT (
        RxD        : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        reset      : IN     std_ulogic ;
        RS232Data  : OUT    std_ulogic_vector (uartDataBitNb-1 DOWNTO 0);
        RS232Valid : OUT    std_ulogic ;
        debug0     : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT Rs232ToRam
    GENERIC (
        dataBitNb    : integer;
        DATA_WIDTH   : integer;
        addressBitNb : integer
    );
    PORT (
        NewCoeff   : IN     std_ulogic ;
        RS232Coeff : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock      : IN     std_ulogic ;
        outputEn   : IN     std_ulogic ;
        reset      : IN     std_ulogic ;
        addressBRs : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInBRs  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        writeEnRs  : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT SeialSync
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        DataReady   : IN     std_ulogic ;
        LR_I        : IN     std_uLogic ;
        NewData     : IN     std_uLogic ;
        clock       : IN     std_uLogic ;
        highPass    : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass     : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        reset       : IN     std_uLogic ;
        audioLeft1  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight1 : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT Xover_with_RAM
    GENERIC (
        DATA_WIDTH    : positive;
        COEFF_BIT_NB  : positive;
        dataBitNb     : positive;
        addressBitNb  : positive;
        FILTER_TAP_NB : positive
    );
    PORT (
        DataInCoeffs : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        audio_In     : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock        : IN     std_ulogic ;
        dout1        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        filterTapNb  : IN     integer RANGE 999 DOWNTO 0;
        newSample    : IN     std_logic ;
        reset        : IN     std_ulogic ;
        DataReady    : OUT    std_ulogic ;
        DebugData    : OUT    unsigned (1 DOWNTO 0);
        din          : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        highPass     : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass      : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        rdaddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re           : OUT    std_ulogic ;
        we           : OUT    std_ulogic ;
        wraddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        writeEnA     : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT delayer
    PORT (
        Data         : IN     std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        Data_delayed : OUT    std_logic 
    );
    END COMPONENT;
    COMPONENT iisDecoder
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        reset      : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        LRCK       : IN     std_ulogic ;
        SCK        : IN     std_ulogic ;
        DOUT       : IN     std_ulogic ;
        dataValid  : OUT    std_ulogic ;
        audioLeft  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        lr2        : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT iisEncoder
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        reset      : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        audioLeft  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        LRCK       : OUT    std_ulogic ;
        SCK        : OUT    std_ulogic ;
        DOUT       : OUT    std_ulogic ;
        CLKI2s     : IN     std_uLogic ;
        LRCK1      : IN     std_uLogic ;
        NewData    : OUT    std_uLogic ;
        Frameout0  : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT muxOut
    PORT (
        DOUT   : IN     std_ulogic ;
        LRCK   : IN     std_ulogic ;
        SCK    : IN     std_ulogic ;
        en     : IN     std_ulogic ;
        CLK_O  : OUT    std_uLogic ;
        Data_O : OUT    std_uLogic ;
        LR_O   : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT risingEdgeDetector
    PORT (
        clock     : IN     std_logic ;
        dataValid : IN     std_logic ;
        reset     : IN     std_logic ;
        en        : OUT    std_logic 
    );
    END COMPONENT;
    COMPONENT testerRS232
    GENERIC (
        uartDataBitNb : positive;
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive
    );
    PORT (
        RS232Data   : IN     std_ulogic_vector (uartDataBitNb -1 DOWNTO 0);
        RS232Valid  : IN     std_ulogic ;
        clock       : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        FilterTapNb : OUT    integer RANGE 999 DOWNTO 0;
        NewCoeff    : OUT    std_ulogic ;
        RS232Coeff  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        outputEn    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT bascule
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        audio_L_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock       : IN     std_ulogic ;
        dataVAlid   : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        audio_L_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : CoeffWriter USE ENTITY Splitter.CoeffWriter;
    FOR ALL : MuxRAM USE ENTITY Splitter.MuxRAM;
    FOR ALL : RS232_reciver USE ENTITY Splitter.RS232_reciver;
    FOR ALL : Rs232ToRam USE ENTITY Splitter.Rs232ToRam;
    FOR ALL : SeialSync USE ENTITY Splitter.SeialSync;
    FOR ALL : Xover_with_RAM USE ENTITY Splitter.Xover_with_RAM;
    FOR ALL : bascule USE ENTITY Splitter_test.bascule;
    FOR ALL : bramDualport USE ENTITY Memory.bramDualport;
    FOR ALL : delayer USE ENTITY Splitter.delayer;
    FOR ALL : iisDecoder USE ENTITY Splitter.iisDecoder;
    FOR ALL : iisEncoder USE ENTITY Splitter.iisEncoder;
    FOR ALL : muxOut USE ENTITY Splitter.muxOut;
    FOR ALL : risingEdgeDetector USE ENTITY Splitter.risingEdgeDetector;
    FOR ALL : testerRS232 USE ENTITY Splitter.testerRS232;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    testOut(0) <= outputEn;
    testOut(1) <= newSample;
    testOut(2) <= '0';
    testOut(3) <= newCoeff;
    testOut(4) <= DebugData(0);
    testOut(5) <= DebugData(1);
    testOut(6) <= DebugData(1);


    -- Instance port mappings.
    I3 : bramDualport
        GENERIC MAP (
            addressBitNb => addressBitNb,
            dataBitNb    => dataBitNb,
            initFile     => initFile
        )
        PORT MAP (
            clockA   => clock,
            enA      => we,
            writeEnA => writeEnA,
            addressA => wraddr,
            dataInA  => din,
            dataOutA => dataOutA,
            clockB   => clock,
            enB      => enB,
            writeEnB => writeEnB1,
            addressB => addressB1,
            dataInB  => dataInB1,
            dataOutB => dataOutB
        );
    I10 : CoeffWriter
        GENERIC MAP (
            addressBitNb  => 	addressBitNb,
            dataBitNb     => dataBitNb,
            COEFF_BIT_NB  => COEFF_BIT_NB,
            DATA_WIDTH    => DATA_WIDTH,
            FILTER_TAP_NB => FILTER_TAP_NB
        )
        PORT MAP (
            clock    => clock,
            reset    => reset,
            addressB => addressB,
            dataInB  => dataInB,
            enB      => enB1,
            writeEnB => writeEnB
        );
    I12 : MuxRAM
        GENERIC MAP (
            dataBitNb    => dataBitNb,
            addressBitNb => addressBitNb
        )
        PORT MAP (
            addressB   => addressB,
            addressBRs => addressBRs,
            dataInB    => dataInB,
            dataInBRs  => dataInBRs,
            enB1       => enB1,
            outputEn   => outputEn,
            rdaddr     => rdaddr,
            re         => re,
            writeEnB   => writeEnB,
            writeEnRs  => writeEnRs,
            addressB1  => addressB1,
            dataInB1   => dataInB1,
            enB        => enB,
            writeEnB1  => writeEnB1
        );
    I13 : RS232_reciver
        GENERIC MAP (
            uartDataBitNb  => uartDataBitNb,
            baudRateDivide => integer(clockFrequency/uartBaudRate + 0.5)
        )
        PORT MAP (
            RxD        => RxD_synch,
            clock      => clock,
            reset      => reset,
            RS232Data  => RS232Data,
            RS232Valid => RS232Valid,
            debug0     => debug0
        );
    I15 : Rs232ToRam
        GENERIC MAP (
            dataBitNb    => dataBitNb,
            DATA_WIDTH   => DATA_WIDTH,
            addressBitNb => addressBitNb
        )
        PORT MAP (
            NewCoeff   => NewCoeff,
            RS232Coeff => RS232Coeff,
            clock      => clock,
            outputEn   => outputEn,
            reset      => reset,
            addressBRs => addressBRs,
            dataInBRs  => dataInBRs,
            writeEnRs  => writeEnRs
        );
    I4 : SeialSync
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            DataReady   => end_Calc,
            LR_I        => LR_I,
            NewData     => Next_data,
            clock       => clock,
            highPass    => highPass,
            lowPass     => lowPass,
            reset       => reset,
            audioLeft1  => audioLeft1,
            audioRight1 => audioRight1
        );
    I11 : Xover_with_RAM
        GENERIC MAP (
            DATA_WIDTH    => DATA_WIDTH,
            COEFF_BIT_NB  => COEFF_BIT_NB,
            dataBitNb     => dataBitNb,
            addressBitNb  => addressBitNb,
            FILTER_TAP_NB => FILTER_TAP_NB
        )
        PORT MAP (
            DataInCoeffs => dataOutB,
            audio_In     => audio_R_out,
            clock        => clock,
            dout1        => dataOutA,
            filterTapNb  => FilterTapNb,
            newSample    => newSample,
            reset        => reset,
            DataReady    => DataReady,
            DebugData    => DebugData,
            din          => din,
            highPass     => highPass,
            lowPass      => lowPass,
            rdaddr       => rdaddr,
            re           => re,
            we           => we,
            wraddr       => wraddr,
            writeEnA     => writeEnA
        );
    I9 : delayer
        PORT MAP (
            Data         => Data,
            clock        => clock,
            reset        => reset,
            Data_delayed => newSample
        );
    I0 : iisDecoder
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            reset      => reset,
            clock      => clock,
            LRCK       => LR_I,
            SCK        => CLK_I,
            DOUT       => Data_I,
            dataValid  => dataValid,
            audioLeft  => audioLeft,
            audioRight => audioRight,
            lr2        => OPEN
        );
    I2 : iisEncoder
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            reset      => reset,
            clock      => clock,
            audioLeft  => audioLeft1,
            audioRight => audioRight1,
            LRCK       => LRCK,
            SCK        => SCK,
            DOUT       => DOUT,
            CLKI2s     => CLK_I,
            LRCK1      => LR_I,
            NewData    => NewData,
            Frameout0  => Frameout0
        );
    I8 : muxOut
        PORT MAP (
            DOUT   => DOUT,
            LRCK   => LRCK,
            SCK    => SCK,
            en     => outputEn,
            CLK_O  => CLK_O,
            Data_O => Data_O,
            LR_O   => LR_O
        );
    I5 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => dataValid,
            reset     => reset,
            en        => Data
        );
    I6 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => DataReady,
            reset     => reset,
            en        => end_Calc
        );
    I7 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => NewData,
            reset     => reset,
            en        => Next_data
        );
    I14 : testerRS232
        GENERIC MAP (
            uartDataBitNb => uartDataBitNb,
            DATA_WIDTH    => DATA_WIDTH,
            FILTER_TAP_NB => FILTER_TAP_NB
        )
        PORT MAP (
            RS232Data   => RS232Data,
            RS232Valid  => RS232Valid,
            clock       => clock,
            reset       => reset,
            FilterTapNb => FilterTapNb,
            NewCoeff    => NewCoeff,
            RS232Coeff  => RS232Coeff,
            outputEn    => outputEn
        );
    I1 : bascule
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            audio_L_in  => audioRight,
            audio_R_in  => audioLeft,
            clock       => clock,
            dataVAlid   => Data,
            reset       => reset,
            audio_L_out => OPEN,
            audio_R_out => audio_R_out
        );

END visitorsVersion;




-- VHDL Entity gates.inverter.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY inverter IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverter ;





ARCHITECTURE sim OF inverter IS
BEGIN
  out1 <= NOT in1 after delay;
END sim;




-- VHDL Entity gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




-- VHDL Entity sequential.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY DFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0' after delay;
    elsif rising_edge(clk) then
      q <= d after delay;
    end if;
  end process;

END sim;




--
-- VHDL Architecture Board.FPGA_splitter.struct
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 16:50:18 04.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
  USE gates.gates.all;
LIBRARY Common;
  USE Common.CommonLib.all;

LIBRARY sequential;
LIBRARY Splitter;

ARCHITECTURE struct OF FPGA_splitter IS

    -- Architecture declarations
    constant clockFrequency: real := 48.0E6;
    constant rs232BaudRate: real := 9.6E3;
    constant pwmFrequency: real := 100.0E3;
    constant mainsFrequency: real := 50.0;
    constant debounceCounterBitNb: positive := requiredBitNb(integer(clockFrequency/100.0));
    constant spikeFilterCounterBitNb: positive := requiredBitNb(10);
    constant buttonsRepeatFrequency: real := 100.0;
    constant controlAmplitudeBitNb: natural := 10;
    constant proportionalShift: integer := -14;
    constant integratorShift: integer := -12;
    constant testLineNb: positive := 16;

    -- Internal signal declarations
    SIGNAL CLK_I        : std_uLogic;
    SIGNAL CLK_O1       : std_uLogic;
    SIGNAL Data_I       : std_uLogic;
    SIGNAL Data_O1      : std_uLogic;
    SIGNAL LR_I         : std_uLogic;
    SIGNAL LR_O1        : std_ulogic;
    SIGNAL RxD_synch    : std_uLogic;
    SIGNAL reset        : std_ulogic;
    SIGNAL reset1       : std_ulogic;
    SIGNAL resetSynch   : std_ulogic;
    SIGNAL resetSynch_n : std_ulogic;


    -- Component Declarations
    COMPONENT inverter
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT DFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT leftRightSplitter
    GENERIC (
        signalBitNb  : positive := 24;
        signalOBitNb : positive := 32
    );
    PORT (
        CLK_I     : IN     std_uLogic ;
        Data_I    : IN     std_uLogic ;
        LR_I      : IN     std_uLogic ;
        RxD_synch : IN     std_ulogic ;
        S21       : IN     std_ulogic ;
        S22       : IN     std_ulogic ;
        S23       : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        CLK_O     : OUT    std_uLogic ;
        Data_O    : OUT    std_uLogic ;
        LR_O      : OUT    std_ulogic ;
        testOut   : OUT    std_ulogic_vector (6 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : DFF USE ENTITY sequential.DFF;
    FOR ALL : inverter USE ENTITY gates.inverter;
    FOR ALL : leftRightSplitter USE ENTITY Splitter.leftRightSplitter;
    FOR ALL : logic1 USE ENTITY gates.logic1;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I1 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => reset_n,
            out1 => reset
        );
    I7 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => resetSynch_n,
            out1 => resetSynch
        );
    I28 : logic1
        PORT MAP (
            logic_1 => reset1
        );
    I_rst : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => reset1,
            Q   => resetSynch_n
        );
    I_rst1 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => LR_In,
            Q   => LR_I
        );
    I_rst2 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => Data_In,
            Q   => Data_I
        );
    I_rst3 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => CLK_In,
            Q   => CLK_I
        );
    I_rst4 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => Data_O1,
            Q   => Data_O
        );
    I_rst5 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => CLK_O1,
            Q   => CLK_O
        );
    I_rst6 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => LR_O1,
            Q   => LR_O
        );
    I_rst7 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => RxD,
            Q   => RxD_synch
        );
    I0 : leftRightSplitter
        GENERIC MAP (
            signalBitNb  => 24,
            signalOBitNb => 32
        )
        PORT MAP (
            CLK_I     => CLK_I,
            Data_I    => Data_I,
            LR_I      => LR_I,
            RxD_synch => RxD_synch,
            S21       => S21,
            S22       => S22,
            S23       => S23,
            clock     => clock,
            reset     => resetSynch,
            CLK_O     => CLK_O1,
            Data_O    => Data_O1,
            LR_O      => LR_O1,
            testOut   => testOut
        );

END struct;




