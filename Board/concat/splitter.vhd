-- VHDL Entity Board.FPGA_splitter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:34:42 02.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FPGA_splitter IS
    GENERIC( 
        buttonNb : positive := 4;
        ledNb    : positive := 8
    );
    PORT( 
        CLK_In  : IN     std_uLogic;
        Data_In : IN     std_uLogic;
        LR_In   : IN     std_uLogic;
        RxD     : IN     std_uLogic;
        S20     : IN     std_ulogic;
        S21     : IN     std_ulogic;
        S22     : IN     std_ulogic;
        S23     : IN     std_ulogic;
        S30     : IN     std_ulogic;
        S31     : IN     std_ulogic;
        S32     : IN     std_ulogic;
        S33     : IN     std_ulogic;
        S40     : IN     std_ulogic;
        S41     : IN     std_ulogic;
        S42     : IN     std_ulogic;
        S43     : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset_n : IN     std_ulogic;
        CLK_O   : OUT    std_uLogic;
        Data_O  : OUT    std_uLogic;
        LR_O    : OUT    std_ulogic;
        testOut : OUT    std_ulogic_vector (6 DOWNTO 0)
    );

-- Declarations

END FPGA_splitter ;





-- VHDL Entity Splitter.leftRightSplitter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:48:22 02.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY leftRightSplitter IS
    GENERIC( 
        signalBitNb  : positive := 24;
        signalOBitNb : positive := 32
    );
    PORT( 
        CLK_I     : IN     std_uLogic;
        Data_I    : IN     std_uLogic;
        LR_I      : IN     std_uLogic;
        RxD_synch : IN     std_ulogic;
        S20       : IN     std_ulogic;
        S21       : IN     std_ulogic;
        S22       : IN     std_ulogic;
        S23       : IN     std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        CLK_O     : OUT    std_uLogic;
        Data_O    : OUT    std_uLogic;
        LR_O      : OUT    std_ulogic;
        testOut   : OUT    std_ulogic_vector (6 DOWNTO 0)
    );

-- Declarations

END leftRightSplitter ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




-- VHDL Entity Splitter.iisDecoder.symbol
--
-- Created:
--          by - maxim.UNKNOWN (DESKTOP-ADLE19A)
--          at - 15:36:40 19/07/2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY iisDecoder IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        reset      : IN     std_ulogic;
        clock      : IN     std_ulogic;
        LRCK       : IN     std_ulogic;
        SCK        : IN     std_ulogic;
        DOUT       : IN     std_ulogic;
        dataValid  : OUT    std_ulogic;
        audioLeft  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        lr2        : OUT    std_ulogic
    );

-- Declarations

END iisDecoder ;





--------------------------------------------------------------------------------
-- decoding the i2s input to DATA_WIDTH registers 
--------------------------------------------------------------------------------
ARCHITECTURE MYArchi OF iisDecoder IS
   signal sckDelayed, sckRising, sckFalling : std_ulogic;
   signal lrckDelayed, lrckChanged : std_ulogic;
   signal lrSel1, lrSel : std_ulogic;
   signal lrCounter1, lrCounter : unsigned(4 downto 0); -- count to 32
BEGIN

   delaySck : process (reset, clock)
   begin
      if reset = '1' then
         sckDelayed <= '0';
         lrckDelayed <= '0';
      elsif rising_edge(clock) then
         -- 1 clock period delay to detect the edges
         sckDelayed <= SCK;
         lrckDelayed <= LRCK;
      end if;
   end process delaySck;
   -- edges detection
   sckRising <= '1' when (SCK = '1') and (sckDelayed = '0') else '0';
   sckFalling <= '1' when (SCK = '0') and (sckDelayed = '1')else '0';
   lrckChanged <= '1' when LRCK /= lrckDelayed else '0';
   
   
   countBits : process (reset, clock)
   begin
      if reset = '1' then
         lrCounter1 <= (others => '1');
         lrCounter <= (others => '1');
      elsif rising_edge(clock) then
         
         if lrckChanged = '1' then
            -- reseting the lr counter1
            lrCounter1 <= (others => '1');
         elsif sckRising = '1' then
            -- substracting the LRcounter1 at the rising edge
            lrCounter1 <= lrCounter1 - 1;
         end if;
         if sckFalling = '1' then
            -- updating the counter at the falling edge 
            -- (+1 because of the nature of the i2s protocole)
            lrCounter <= lrCounter1 + 1;
         end if;
      end if;
   end process countBits;
   
   shiftLrSel : process (reset, clock)
   begin
      if reset = '1' then
         lrSel1 <= '0';
         lrSel <= '0';
      elsif rising_edge(clock) then
         -- shifting the LR to comply with the i2s protocole
         if sckRising = '1' then
            lrSel1 <= LRCK;
         elsif sckFalling = '1' then
            lrSel <= lrSel1;
         end if;
      end if;
   end process shiftLrSel;
   
   fillReg : process (clock, reset)
   begin
      if reset = '1' then
         audioLeft <= (others => '0');
         audioRight <= (others => '0');
      elsif rising_edge(clock) then
         if sckRising = '1' then
         -- updating the outputs bits in function of leSel and lrCounter
            if lrSel = '1' then 
               audioLeft(to_integer(lrCounter)) <= DOUT;
            else
               audioRight(to_integer(lrCounter)) <= DOUT;
            end if;
         end if;
      end if;
   end process fillReg;
   lr2 <= lrSel;
   dataValid <= '1' when lrCounter = 0 and SCK = '1' and LRCK = '1' else '0';
   --dataValid <= '1' when lrCounter = 0 and SCK = '1' else '0';
END ARCHITECTURE MYArchi;



-- VHDL Entity Splitter_test.bascule.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:27:20 09.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY bascule IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        audio_L_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock       : IN     std_ulogic;
        dataVAlid   : IN     std_ulogic;
        reset       : IN     std_ulogic;
        audio_L_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );

-- Declarations

END bascule ;





--------------------------------------------------------------
-- register to sync the iis decoder with the others blocks 
--------------------------------------------------------------
ARCHITECTURE test_lowpas_i2s OF bascule IS
   signal cnt :  unsigned (2 downto 0);
BEGIN
   FlipFlopAndResize: process(reset, clock)
   begin
      if reset = '1' then
         audio_R_out <= (others => '0');
         audio_L_out <= (others => '0');
         cnt <= (others => '0');
      elsif rising_edge(clock) then
         if dataValid = '1' then
            audio_R_out <= audio_R_in;
            audio_L_out <= audio_L_in;      
         end if;             
      end if;
   end process FlipFlopAndResize;
END ARCHITECTURE test_lowpas_i2s;





-- VHDL Entity Splitter.CoeffWriter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:37:35 01.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY CoeffWriter IS
    GENERIC( 
        addressBitNb  : positive;
        dataBitNb     : positive;
        FILTER_TAP_NB : positive;
        COEFF_BIT_NB  : positive;
        DATA_WIDTH    : positive
    );
    PORT( 
        clock    : IN     std_ulogic;
        reset    : IN     std_ulogic;
        addressB : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB      : OUT    std_ulogic;
        writeEnB : OUT    std_ulogic
    );

-- Declarations

END CoeffWriter ;





--
-- VHDL Architecture Splitter.CoeffWriter.Archi1
--
-- Created:
-- by - maxime.cesalli.UNKNOWN (WE2330804)
-- at - 15:22:31 18.07.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE Archi1 OF CoeffWriter IS
   constant HALF_FILTER_TAP_NB : positive := FILTER_TAP_NB/2 + (FILTER_TAP_NB mod 2);
   signal firstWrite : unsigned(3 downto 0);
   signal wAddrCnt : unsigned(addressBitNb - 1 downto 0);
   signal arrayCnt : unsigned(addressBitNb - 1 downto 0);
   signal writeCoeffs : std_ulogic;

   constant n : positive := 1;
   constant initialWAddress : integer := 1024;
   constant RAMLength : positive := (((FILTER_TAP_NB * n * 2) + initialWAddress) - 1);
   -- lowpass firtst then highpass coeff
   type coefficients is array (0 to 1, 0 to HALF_FILTER_TAP_NB - 1) of signed(COEFF_BIT_NB - 1 downto 0);
   signal coeff : coefficients := (
      (
      x"FFFFF398", x"FFFFDCDB", x"FFFFC5DE", x"FFFFB1BE", x"FFFFA3BE", 
      x"FFFF9ED7", x"FFFFA548", x"FFFFB826", x"FFFFD710", x"00000000", 
      x"00002F5A", x"00006029", x"00008C94", x"0000AE7F", x"0000C04E", 
      x"0000BDA8", x"0000A42D", x"000073FC", x"00003003", x"FFFFDDF5", 
      x"FFFF85E4", x"FFFF3191", x"FFFEEB6A", x"FFFEBD56", x"FFFEAF75", 
      x"FFFEC6F6", x"FFFF0527", x"FFFF66E3", x"FFFFE481", x"00007245", 
      x"00010162", x"00018167", x"0001E209", x"00021516", x"0002104C", 
      x"0001CEF2", x"000152E2", x"0000A4EF", x"FFFFD47B", x"FFFEF641", 
      x"FFFE2269", x"FFFD7201", x"FFFCFC31", x"FFFCD35F", x"FFFD02AE", 
      x"FFFD8C19", x"FFFE6779", x"FFFF82A6", x"0000C2BA", x"0002067C", 
      x"000329A7", x"000408D4", x"0004859C", x"00048A69", x"00040D9B", 
      x"00031380", x"0001AEE6", x"00000000", x"FFFE31BB", x"FFFC75A7", 
      x"FFFAFECF", x"FFF9FC14", x"FFF9928F", x"FFF9D8B5", x"FFFAD2CD", 
      x"FFFC7138", x"FFFE90D9", x"0000FDBA", x"000377CD", x"0005B94A", 
      x"00077E2E", x"00088BF6", x"0008B8CF", x"0007F159", x"00063C3C", 
      x"0003BB0C", x"0000A839", x"FFFD520C", x"FFFA131E", x"FFF748FD", 
      x"FFF549E5", x"FFF45AB0", x"FFF4A61C", x"FFF6367F", x"FFF8F2B3", 
      x"FFFC9ED2", x"0000E0DE", x"00054905", x"00095CD1", x"000CA42D", 
      x"000EB6DB", x"000F48ED", x"000E34CA", x"000B8177", x"00076447", 
      x"00023D7A", x"FFFC8FEA", x"FFF6F468", x"FFF20A00", x"FFEE64B6", 
      x"FFEC7C8B", x"FFEC9EBB", x"FFEEE2F8", x"FFF325FF", x"FFF90A69", 
      x"00000000", x"0007510E", x"000E3480", x"0013E31C", x"0017AD8E", 
      x"001910F7", x"0017C78F", x"0013D361", x"000D819F", x"000565D6", 
      x"FFFC4D25", x"FFF32A71", x"FFEAFD88", x"FFE4B79F", x"FFE1200E", 
      x"FFE0BC71", x"FFE3BECD", x"FFE9FC21", x"FFF2ECB5", x"FFFDB6A6", 
      x"000941F8", x"0014546D", x"001DB264", x"0024416B", x"002728C0", 
      x"0025EC15", x"00207D73", x"001743C4", x"000B14DB", x"FFFD2317", 
      x"FFEEDFF6", x"FFE1D685", x"FFD78142", x"FFD11FF6", x"FFCF9219", 
      x"FFD33A1C", x"FFDBED1B", x"FFE8F14B", x"FFF90C01", x"000A9E66", 
      x"001BCE68", x"002AB7E8", x"0035A128", x"003B2CDC", x"003A8455", 
      x"003374C1", x"00267BD4", x"0014C1B1", x"00000000", x"FFEA5809", 
      x"FFD61BBA", x"FFC58F0A", x"FFBAA825", x"FFB6D566", x"FFBACF95", 
      x"FFC67E04", x"FFD8F03D", x"FFF06EEF", x"000AA335", x"0024D0E9", 
      x"003C1E70", x"004DE2D0", x"0057F1D2", x"0058DDD5", x"005027BD", 
      x"003E5709", x"0024F66B", x"00067426", x"FFE5E84E", x"FFC6C62E", 
      x"FFAC8067", x"FF9A291E", x"FF921889", x"FF95A3AC", x"FFA4EC03", 
      x"FFBECE51", x"FFE0F3D1", x"00080569", x"002FFCD9", x"00548C65", 
      x"007192DD", x"00838FFF", x"00880CB7", x"007DEB77", x"006596F7", 
      x"004108D2", x"0013A57D", x"FFE1EF8C", x"FFB11899", x"FF867A33", 
      x"FF670421", x"FF56AF14", x"FF58031A", x"FF6BBFB5", x"FF90B094", 
      x"FFC3B59E", x"00000000", x"003F803E", x"007B7C12", x"00AD3E1C", 
      x"00CECE27", x"00DB9EED", x"00D11E81", x"00AF18A7", x"0077DE69", 
      x"00302BA3", x"FFDEC9D2", x"FF8BF647", x"FF409885", x"FF055B07", 
      x"FEE1BCCB", x"FEDB33C0", x"FEF477EA", x"FF2D0BFC", x"FF81133D", 
      x"FFE97D6F", x"005C8974", x"00CE96C5", x"01333588", x"017E5E34", 
      x"01A5B495", x"01A1B75A", x"016EBDD6", x"010DA8B2", x"00843054", 
      x"FFDCC41F", x"FF25F73D", x"FE718278", x"FDD2EC8C", x"FD5DF397", 
      x"FD24D8EF", x"FD36B4CA", x"FD9DF7CC", x"FE5F3DD5", x"FF788F73", 
      x"00E12683", x"0289BFB8", x"045D76A3", x"06431DF0", x"081EFA61", 
      x"09D4BE19", x"0B499BBD", x"0C664636", x"0D18B2FC", x"0D557996"
      ),
      (
      x"00000C68", x"00002325", x"00003A21", x"00004E41", x"00005C41", 
      x"00006128", x"00005AB7", x"000047D9", x"000028F0", x"00000000", 
      x"FFFFD0A6", x"FFFF9FD8", x"FFFF736E", x"FFFF5183", x"FFFF3FB4", 
      x"FFFF425A", x"FFFF5BD5", x"FFFF8C05", x"FFFFCFFD", x"0000220A", 
      x"00007A1B", x"0000CE6D", x"00011493", x"000142A7", x"00015088", 
      x"00013907", x"0000FAD7", x"0000991C", x"00001B7F", x"FFFF8DBC", 
      x"FFFEFEA0", x"FFFE7E9D", x"FFFE1DFC", x"FFFDEAF0", x"FFFDEFBA", 
      x"FFFE3113", x"FFFEAD21", x"FFFF5B13", x"00002B84", x"000109BC", 
      x"0001DD92", x"00028DF8", x"000303C7", x"00032C98", x"0002FD4A", 
      x"000273E1", x"00019883", x"00007D59", x"FFFF3D48", x"FFFDF989", 
      x"FFFCD662", x"FFFBF737", x"FFFB7A70", x"FFFB75A3", x"FFFBF270", 
      x"FFFCEC88", x"FFFE511E", x"00000000", x"0001CE40", x"00038A50", 
      x"00050123", x"000603DB", x"00066D5F", x"0006273A", x"00052D25", 
      x"00038EBE", x"00016F24", x"FFFF0249", x"FFFC883D", x"FFFA46C5", 
      x"FFF881E6", x"FFF77422", x"FFF74749", x"FFF80EBC", x"FFF9C3D5", 
      x"FFFC44FE", x"FFFF57C9", x"0002ADED", x"0005ECD2", x"0008B6EC", 
      x"000AB5FE", x"000BA531", x"000B59C5", x"0009C967", x"00070D3A", 
      x"00036125", x"FFFF1F25", x"FFFAB70A", x"FFF6A348", x"FFF35BF5", 
      x"FFF1494D", x"FFF0B73D", x"FFF1CB5D", x"FFF47EA8", x"FFF89BCD", 
      x"FFFDC28C", x"0003700D", x"00090B80", x"000DF5DA", x"00119B1A", 
      x"00138341", x"00136111", x"00111CD9", x"000CD9DE", x"0006F584", 
      x"00000000", x"FFF8AF06", x"FFF1CBA6", x"FFEC1D1A", x"FFE852B2", 
      x"FFE6EF4D", x"FFE838B1", x"FFEC2CD5", x"FFF27E86", x"FFFA9A38", 
      x"0003B2D1", x"000CD56D", x"0015023F", x"001B4818", x"001EDF9E", 
      x"001F433B", x"001C40E6", x"001603A3", x"000D1328", x"00024954", 
      x"FFF6BE21", x"FFEBABCA", x"FFE24DEC", x"FFDBBEF7", x"FFD8D7AA", 
      x"FFDA1452", x"FFDF82E5", x"FFE8BC7B", x"FFF4EB43", x"0002DCE1", 
      x"00111FDC", x"001E2929", x"00287E50", x"002EDF8C", x"00306D64", 
      x"002CC56B", x"00241284", x"00170E77", x"0006F3EC", x"FFF561B7", 
      x"FFE431E3", x"FFD5488B", x"FFCA5F6A", x"FFC4D3C4", x"FFC57C49", 
      x"FFCC8BCA", x"FFD98495", x"FFEB3E87", x"00000000", x"0015A7BD", 
      x"0029E3D4", x"003A7058", x"0045571F", x"004929D4", x"00452FB0", 
      x"00398161", x"00270F59", x"000F90E7", x"FFF55CE8", x"FFDB2F7A", 
      x"FFC3E233", x"FFB21E03", x"FFA80F1C", x"FFA7231B", x"FFAFD91C", 
      x"FFC1A9A0", x"FFDB09F9", x"FFF98BEC", x"001A176B", x"00393937", 
      x"00537EB7", x"0065D5CE", x"006DE64D", x"006A5B34", x"005B1306", 
      x"004130FE", x"001F0BDB", x"FFF7FAAD", x"FFD003A9", x"FFAB7480", 
      x"FF8E6E56", x"FF7C7165", x"FF77F4B9", x"FF8215DE", x"FF9A6A1C", 
      x"FFBEF7DE", x"FFEC5AB8", x"001E1023", x"004EE692", x"00798484", 
      x"0098FA41", x"00A94F21", x"00A7FB1F", x"00943EBA", x"006F4E3F", 
      x"003C49BF", x"00000000", x"FFC0806E", x"FF84853C", x"FF52C3B9", 
      x"FF313409", x"FF246365", x"FF2EE3B6", x"FF50E933", x"FF8822DC", 
      x"FFCFD4DF", x"002135D4", x"0074087F", x"00BF6575", x"00FAA252", 
      x"011E402E", x"0124C927", x"010B8542", x"00D2F1C8", x"007EEB6B", 
      x"00168254", x"FFA37787", x"FF316B6A", x"FECCCDB8", x"FE81A5D7", 
      x"FE5A4FE1", x"FE5E4D11", x"FE91460A", x"FEF25A28", x"FF7BD111", 
      x"00233B81", x"00DA0674", x"018E7951", x"022D0D90", x"02A20548", 
      x"02DB1F56", x"02C943AB", x"026201C1", x"01A0BDC3", x"00876F1E", 
      x"FF1EDBDE", x"FD764727", x"FBA2952F", x"F9BCF304", x"F7E11B9B", 
      x"F62B5C85", x"F4B682D2", x"F399DB5C", x"F2E77079", x"72AAABFB"
      )
   );
begin
   RamWriter : process (clock, reset)
   begin
      if (reset = '1') then
         firstWrite <= (others => '0');
         arrayCnt <= (others => '0');
         wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
         writeCoeffs <= '1';
      elsif rising_edge(clock) then
         if writeCoeffs = '1' then
            wAddrCnt <= wAddrCnt + n;
            addressB <= std_ulogic_vector(wAddrCnt);
            writeEnB <= '1';
            enB <= '1';
            if arrayCnt <= HALF_FILTER_TAP_NB - 1 then
               if firstWrite = 0 then
                  firstWrite <= firstWrite + 1;
                  dataInB <= std_ulogic_vector(unsigned(coeff(1, to_integer(arrayCnt))
                  (COEFF_BIT_NB - 1 downto (COEFF_BIT_NB - (COEFF_BIT_NB/2)))));
               end if;
               if firstWrite = 1 then
                  firstWrite <= firstWrite + 1;
                  dataInB <= std_ulogic_vector(unsigned(coeff(1, to_integer(arrayCnt))
                     ((COEFF_BIT_NB - (COEFF_BIT_NB/2) - 1) downto 0)));
               end if;
               if firstWrite = 2 then
                  firstWrite <= firstWrite + 1;
                  dataInB <= std_ulogic_vector(unsigned(coeff(0, to_integer(arrayCnt))
                  (COEFF_BIT_NB - 1 downto (COEFF_BIT_NB - (COEFF_BIT_NB/2)))));
               end if;
               if firstWrite = 3 then
                  arrayCnt <= arrayCnt + 1;
                  firstWrite <= (others => '0');
                  dataInB <= std_ulogic_vector(unsigned(coeff(0, to_integer(arrayCnt))
                  ((COEFF_BIT_NB - (COEFF_BIT_NB/2) - 1) downto 0)));
               end if;
            end if;
            if arrayCnt = HALF_FILTER_TAP_NB and firstWrite = 0 then
               writeCoeffs <= '0';
               enB <= '0';
               writeEnB <= '0';
               wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
            end if;
         end if;
      end if;
   end process RamWriter;  
END ARCHITECTURE Archi1;



-- VHDL Entity Splitter.Xover_with_RAM.symbol
--
-- Created:
--          by - maxim.UNKNOWN (DESKTOP-ADLE19A)
--          at - 16:12:37 30/07/2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY Xover_with_RAM IS
    GENERIC( 
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive;
        COEFF_BIT_NB  : positive;
        dataBitNb     : positive;
        addressBitNb  : positive
    );
    PORT( 
        DataInCoeffs : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        audio_In     : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock        : IN     std_ulogic;
        dout1        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        en           : IN     std_logic;
        reset        : IN     std_ulogic;
        DataReady    : OUT    std_ulogic;
        DebugData    : OUT    unsigned (1 DOWNTO 0);
        din          : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        highPass     : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass      : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        rdaddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re           : OUT    std_ulogic;
        we           : OUT    std_ulogic;
        wraddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        writeEnA     : OUT    std_ulogic
    );

-- Declarations

END Xover_with_RAM ;






ARCHITECTURE symetrical_reading_SR OF Xover_with_RAM IS
   -- constants
   constant n : positive := 1;
   constant initialWAddress : natural := 0;
   constant initialCoeffAddress : natural := 1023;
   constant HALF_FILTER_TAP_NB : positive := FILTER_TAP_NB/2 +
   (FILTER_TAP_NB mod 2);
   constant FINAL_SHIFT : positive := requiredBitNb(FILTER_TAP_NB);
   constant ACCUMULATOR_Bit_NB : positive := COEFF_BIT_NB + audio_In'LENGTH + 
   FINAL_SHIFT;
   constant RAMLength : positive := (((FILTER_TAP_NB * n * 2) +
   initialWAddress) - 1);


   signal debug0 : std_ulogic;
   signal debug1 : std_ulogic;
   signal calculate : std_ulogic; 
   signal calculatedelayed : std_ulogic;
   -- RAM oriented variables ---------------------------------------------------
   signal firstWrite : std_ulogic;
   signal cntNooffset : unsigned(dataBitNb downto 0);
   signal wAddrCnt : unsigned(addressBitNb - 1 downto 0);
   signal coeffAddr : unsigned(addressBitNb - 1 downto 0);
   signal rAddrCnt_Plus : unsigned(addressBitNb - 1 downto 0);
   signal rAddrCnt_Minus : unsigned(addressBitNb - 1 downto 0);
   signal initialRAddress : unsigned(addressBitNb - 1 downto 0);
   signal RAMfull : std_ulogic;
   signal convertsionPoint : std_ulogic;
   signal convertsionPointDelayed : std_ulogic;
   signal sample1L : signed ((audio_In'length/2 )-1 downto 0);
   signal sample1H : signed ((audio_In'length/2 )-1 downto 0);
   signal sample2H : signed ((audio_In'length/2 )-1 downto 0);
   signal sample2L : signed ((audio_In'length/2 )-1 downto 0); 
   signal coeff1L : signed ((audio_In'length/2 )-1 downto 0);
   signal coeff1H : signed ((audio_In'length/2 )-1 downto 0);
   signal coeff2H : signed ((audio_In'length/2 )-1 downto 0);
   signal coeff2L : signed ((audio_In'length/2 )-1 downto 0);
   signal sample1 : signed (audio_In'range);
   signal sample2 : signed (audio_In'range);
   signal HCoeff : signed (audio_In'range);
   signal LCoeff : signed (audio_In'range);
   
   -- array
   -- vector of FILTER_TAP_NB signed elements
   type t_samples is array (0 to FILTER_TAP_NB - 1) of signed (audio_In'range); 
   signal samples : t_samples;

BEGIN
   shiftSamplesAndMul : process (clock, reset)
      variable AccumulaorHP : signed (ACCUMULATOR_Bit_NB - 1 downto 0);
      variable AccumulaorLP : signed (ACCUMULATOR_Bit_NB - 1 downto 0);
   begin
      if (reset = '1') then
         calculate <=  '0';
         calculatedelayed <= '0';
         wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
         coeffAddr <= to_unsigned(initialCoeffAddress, wAddrCnt'length);
         firstWrite <= '0';
         rdaddr <= (others => '0');
         RAMfull <= '0';
         convertsionPoint <= '0';
         convertsionPointDelayed <= '0';
         cntNooffset <= (others => '0');
      elsif rising_edge(clock) then
         convertsionPointDelayed <= convertsionPoint;
         writeEnA <= '0';
         we <= '1';
         if en = '1' then
            firstWrite <= '1';
            -- writing the samples in the RAM
            if ((wAddrCnt + (2 * n) - initialWAddress)) >= RAMLength then
               initialRAddress <= to_unsigned(initialWAddress, initialRAddress'length);
            else
               initialRAddress <= ((wAddrCnt + (2 * n) - initialWAddress));
            end if;
            wAddrCnt <= wAddrCnt + n;
            writeEnA <= '1';
            din <= std_ulogic_vector(unsigned(audio_In(audio_In'LENGTH - 1 downto (audio_In'LENGTH - (audio_In'length/2)))));
            wraddr <= std_ulogic_vector(wAddrCnt);
         end if;
         if firstWrite = '1' then
            calculate <= '1';
            cntNooffset <= (others => '0');
            firstWrite <= '0';
            wAddrCnt <= wAddrCnt + n;
            rAddrCnt_Plus <= initialRAddress;
            rAddrCnt_Minus <= initialRAddress-1;
            wraddr <= std_ulogic_vector(initialRAddress);
            if wAddrCnt >= RAMLength then
               RAMfull <= '1';
               wAddrCnt <= to_unsigned(initialWAddress, wAddrCnt'length);
            end if;
            writeEnA <= '1';
            din <= std_ulogic_vector(unsigned(audio_In((audio_In'LENGTH - (audio_In'length/2) - 1) downto 0)));
            wraddr <= std_ulogic_vector(wAddrCnt);
         end if;
         calculatedelayed <= calculate;
        
         coeffAddr <= to_unsigned(initialCoeffAddress, coeffAddr'length);


         if calculatedelayed = '1' and RAMfull = '1' then
            re <= '0';
          
            if convertsionPointDelayed = '1' then
            
               -- updating the Highpass and Lowpass outpout
               Highpass <= resize(shift_right(AccumulaorHP, ACCUMULATOR_Bit_NB - 
               Highpass'LENGTH - 9), Highpass'length);
               LowPass<= resize(shift_right(AccumulaorLP, ACCUMULATOR_Bit_NB -
               LowPass'LENGTH - 9), LowPass'length);
            
            
               -- reseting everything 
               convertsionPoint <= '0';
               convertsionPointDelayed <= '0';
               calculate <= '0';
               coeffAddr <= to_unsigned(initialCoeffAddress, coeffAddr'length);
               cntNooffset <= (others => '0');
               AccumulaorHP := (others => '0');
               AccumulaorLP := (others => '0');
               
               
            else
               cntNooffset <= cntNooffset + 1;
            end if;
            
            -- coeff adress update and incement 
            rdaddr <= std_ulogic_vector(coeffAddr);
            coeffAddr <= coeffAddr + 1;
           
           
            debug0 <= '0';
            debug1 <= '0';
            
            if cntNooffset mod 4 = 0 then 
               debug0 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               sample2(sample2'LENGTH - 1 downto (sample2'LENGTH - (sample2'length/2))) <= sample2H;
               sample2((sample2'LENGTH - (sample2'length/2) - 1) downto 0) <= sample2L;
               
               -- positive sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Plus);
               rAddrCnt_Plus <= rAddrCnt_Plus + 1;
               
               -- saving the RAM value to create the full data 
               sample1L <= signed(dout1);
               coeff1L <=  signed(DataInCoeffs); 
            elsif cntNooffset mod 4 = 1 then 
               debug0 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               HCoeff(HCoeff'LENGTH - 1 downto (HCoeff'LENGTH - (HCoeff'length/2))) <= coeff1H;
               HCoeff((HCoeff'LENGTH - (HCoeff'length/2) - 1) downto 0) <= coeff1L;
               
               -- positive sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Plus);
               rAddrCnt_Plus <= rAddrCnt_Plus + 1;
               
               -- saving the RAM value to create the full data 
               sample1H <= signed(dout1);
               coeff2H <=  signed(DataInCoeffs);
            elsif cntNooffset mod 4 = 2 then 
               debug1 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               sample1(sample1'LENGTH - 1 downto (sample1'LENGTH - (sample1'length/2))) <= sample1H;
               sample1((sample1'LENGTH - (sample1'length/2) - 1) downto 0) <= sample1L;
               
               -- negative sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Minus);
               rAddrCnt_Minus <= rAddrCnt_Minus - 1;
               
               -- saving the RAM value to create the full data 
               sample2H <= signed(dout1);
               coeff2L <=  signed(DataInCoeffs);
            elsif cntNooffset mod 4 = 3 then 
               debug1 <= '1';
               -- creating the full data with the concateanation of 2 RAM data
               LCoeff(LCoeff'LENGTH - 1 downto (LCoeff'LENGTH - (LCoeff'length/2))) <= coeff2H;
               LCoeff((LCoeff'LENGTH - (LCoeff'length/2) - 1) downto 0) <= coeff2L;
              
               -- negative sample adress upodate and incement
               wraddr <= std_ulogic_vector(rAddrCnt_Minus);
               rAddrCnt_Minus <= rAddrCnt_Minus - 1;
               
               -- saving the RAM value to create the full data 
               coeff1H <=  signed(DataInCoeffs);
               sample2L <= signed(dout1);
            end if;
            -- if we go past the ram length we need 
            if rAddrCnt_Plus >= RAMLength then
               -- reset the counter to intial adress
               rAddrCnt_Plus <= to_unsigned(initialWAddress, wAddrCnt'length);
            end if;
            -- if we go past the ram length we need 
            if rAddrCnt_Minus-1 > RAMLength then
               -- reset the counter to the final adress
              
               rAddrCnt_Minus <= to_unsigned(RAMLength, rAddrCnt_Plus'length);
            end if;
          
            
            -- if the conversion point is reached 
            if cntNooffset = (FILTER_TAP_NB * n * 2 ) + 5 then
               convertsionPoint <= '1';
               -- updates the accumulator with only one sample because
               -- sample1 = sample2 at the conversion Point 
               AccumulaorHP := AccumulaorHP + sample1 * HCoeff;
               AccumulaorLP := AccumulaorLP + sample1 * LCoeff;
            elsif cntNooffset >= 7 and (cntNooffset mod 4) = 0 
            and cntNooffset <= (FILTER_TAP_NB * n * 2 )+ 3 then
               -- updates the accumulators
               AccumulaorHP := AccumulaorHP + (resize(sample1, sample1'LENGTH + 1) + sample2) * HCoeff;
               AccumulaorLP := AccumulaorLP + (resize(sample1, sample1'LENGTH + 1) + sample2) * LCoeff;
            end if;

         end if;
      end if;
   end process shiftSamplesAndMul;
   
   DataReady <= '1' when calculate = '0' else '0';
   DebugData(1) <= convertsionPoint;
   DebugData(0) <= en;
   
END ARCHITECTURE symetrical_reading_SR;



-- VHDL Entity Splitter.RAMmultiplexer.symbol
--
-- Created:
--          by - maxim.UNKNOWN (DESKTOP-ADLE19A)
--          at - 16:14:20 19/07/2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY RAMmultiplexer IS
    GENERIC( 
        addressBitNb : positive
    );
    PORT( 
        addressB  : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        enB       : IN     std_ulogic;
        rdaddr    : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re        : IN     std_ulogic;
        writeEnB  : IN     std_ulogic;
        addressB1 : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        enB1      : OUT    std_ulogic;
        writeEnB1 : OUT    std_ulogic
    );

-- Declarations

END RAMmultiplexer ;





-----------------------------------------------------------------------------
-- multiplexing the acces to the RAM between the coeff writer and the Xover 
-----------------------------------------------------------------------------

ARCHITECTURE Coeffs OF RAMmultiplexer IS
BEGIN

    writeEnB1 <= writeEnB when enB = '1' else re;
    addressB1 <= addressB when enB = '1' else rdaddr;
    enB1 <= '1';


END ARCHITECTURE Coeffs;





-- VHDL Entity Splitter.RS232_reciver.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 11:18:57 02.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY RS232_reciver IS
    GENERIC( 
        uartDataBitNb  : positive;
        baudRateDivide : positive
    );
    PORT( 
        RxD        : IN     std_ulogic;
        clock      : IN     std_ulogic;
        reset      : IN     std_ulogic;
        RS232Data  : OUT    std_ulogic_vector (uartDataBitNb-1 DOWNTO 0);
        RS232Valid : OUT    std_ulogic
    );

-- Declarations

END RS232_reciver ;





--
-- VHDL Architecture Splitter.RS232_reciver.FromMorse_Labo5
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:18:31 02.08.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
-- library Common;
  use work.CommonLib.all;
  
ARCHITECTURE FromMorse_Labo5 OF RS232_reciver IS
 signal dividerCounter: unsigned(requiredBitNb(baudRateDivide-1)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal rxDelayed: std_uLogic;
  signal dividerCounterSynchronize: std_uLogic;
  signal rxSample: std_uLogic;
  signal rxShiftReg: std_ulogic_vector(uartDataBitNb-1 downto 0);
  signal rxReceiving: std_uLogic;
  signal rxDataValid: std_uLogic;
  signal rxCounter: unsigned(requiredBitNb(uartDataBitNb)-1 downto 0);

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterSynchronize = '1' then
        dividerCounter <= to_unsigned(baudRateDivide/2, dividerCounter'length);
      elsif dividerCounterReset = '1' then
        dividerCounter <= (others => '0');
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter)
  begin
    if dividerCounter = baudRateDivide-1 then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  delayRx: process(reset, clock)
  begin
    if reset = '1' then
      rxDelayed <= '0';
    elsif rising_edge(clock) then
      rxDelayed <= RxD;
    end if;
  end process delayRx;

  rxSynchronize: process(RxD, rxDelayed)
  begin
    if RxD /= rxDelayed then
      dividerCounterSynchronize <= '1';
    else
      dividerCounterSynchronize <= '0';
    end if;
  end process rxSynchronize;

  rxSample <= dividerCounterReset;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        rxShiftReg(rxShiftReg'high-1 downto 0) <= rxShiftReg(rxShiftReg'high downto 1);
        rxShiftReg(rxShiftReg'high) <= RxD;
      end if;
    end if;
  end process shiftReg;

  detectReceive: process(reset, clock)
  begin
    if reset = '1' then
      rxReceiving <= '0';
      rxDataValid <= '0';
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxCounter = uartDataBitNb-1 then
          rxDataValid <= '1';
        elsif RxD = '0' then
          rxReceiving <= '1';
        end if;
      elsif rxDataValid = '1' then
        rxReceiving <= '0';
        rxDataValid <= '0';
      end if;
    end if;
  end process detectReceive;

  countRxBitNb: process(reset, clock)
  begin
    if reset = '1' then
      rxCounter <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxReceiving = '1' then
          rxCounter <= rxCounter + 1;
        else
          rxCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countRxBitNb;

  RS232Data <= rxShiftReg;
  RS232Valid <= rxDataValid;

END ARCHITECTURE FromMorse_Labo5;





-- VHDL Entity Splitter.testerRS232.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 11:18:01 02.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY testerRS232 IS
    GENERIC( 
        uartDataBitNb : positive
    );
    PORT( 
        RS232Data  : IN     std_ulogic_vector (uartDataBitNb -1 DOWNTO 0);
        RS232Valid : IN     std_ulogic;
        Debug      : OUT    std_ulogic
    );

-- Declarations

END testerRS232 ;





--
-- VHDL Architecture Splitter.testerRS232.RS232_test1
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:43:22 02.08.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE RS232_test1 OF testerRS232 IS
BEGIN
   
   testter : process(RS232Valid,RS232Data)
   begin 
      debug <= '0';
      if RS232Valid = '1' then 
         if unsigned(RS232Data) = 53 then 
            debug <= '1';
         end if;
      end if;
   end process testter;

END ARCHITECTURE RS232_test1;





-- VHDL Entity Splitter.iisEncoder.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 12:55:40 30.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;  
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY iisEncoder IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        reset      : IN     std_ulogic;
        clock      : IN     std_ulogic;
        audioLeft  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        LRCK       : OUT    std_ulogic;
        SCK        : OUT    std_ulogic;
        DOUT       : OUT    std_ulogic;
        CLKI2s     : IN     std_uLogic;
        LRCK1      : IN     std_uLogic;
        NewData    : OUT    std_uLogic;
        Frameout0  : OUT    std_uLogic
    );

-- Declarations

END iisEncoder ;






ARCHITECTURE inputLRCK OF iisEncoder IS
   
   constant frameLength : positive := audioLeft'length;
   constant frameCounterBitNb : positive := requiredBitNb(frameLength - 1);

   signal lrckDelayed, lrckChanged : std_ulogic;
   signal sckDelayed, sckRising, sckFalling : std_ulogic;
   signal frameCounter : unsigned(frameCounterBitNb - 1 downto 0);
   signal frameCounterDelayed : unsigned(frameCounterBitNb - 1 downto 0);
   signal LRDelayed : std_uLogic;
   signal leftShiftRegister : signed(audioLeft'range);
   signal rightShiftRegister : signed(audioRight'range);

BEGIN
   delaySck : process (reset, clock)
   begin
      if reset = '1' then
         sckDelayed <= '0';
         lrckDelayed <= '0';
      elsif rising_edge(clock) then
         -- 1 clock period delay to detect the edges
         sckDelayed <= CLKI2s;
         lrckDelayed <= LRCK1;
      end if;
   end process delaySck;
    -- edges detection
   sckRising <= '1' when (CLKI2s = '1') and (sckDelayed = '0') else '0';
   sckFalling <= '1' when (CLKI2s = '0') and (sckDelayed = '1') else '0';
   lrckChanged <= '1' when LRCK1 /= lrckDelayed else '0';
   
   FlipFlopAndResize : process (reset, clock)
   begin
      if reset = '1' then
         frameCounter <= (others => '0');
         frameCounterDelayed <= (others => '0');
         leftShiftRegister <= (others => '0');
         rightShiftRegister <= (others => '0');
         LRDelayed <= '0';
      elsif rising_edge(clock) then
         NewData <= '0';
         if sckRising = '1' then
            -- decrementing frame counter
            frameCounter <= frameCounter - 1;
             -- delaying frameCounter
            frameCounterDelayed <= frameCounter;
            -- delaying LR
            LRDelayed <= LRCK1;
         
         elsif sckFalling = '1' then
          -- updating DOUT at the flaaing edge
            if LRDelayed = '0' then
               DOUT <= leftShiftRegister(to_integer(frameCounterDelayed));
            else
               DOUT <= rightShiftRegister(to_integer(frameCounterDelayed));
            end if;
         end if;

         if lrckChanged = '1' then
            -- reseting the frame counter for every new communication
            frameCounter <= (others => '1');
         end if;
         -- asking for the new data at the msb-2 to delete every posiblity of
         -- transition issues (the 3 lasts bits of every data is '0')      
         if frameCounter = 3 and LRDelayed = '1' and CLKI2s = '0' then
            NewData <= '1';
         end if;
         if frameCounter = 3 and LRDelayed = '1' and CLKI2s = '1' then
            -- saving the values to communicate
            rightShiftRegister <= audioRight;
            leftShiftRegister <= audioLeft;
         end if;
         -- updating the outpout
         LRCK <= LRCK1;
         SCK <= CLKI2s;
         -- debug output
         Frameout0 <= frameCounter(0);
      end if;
   end process FlipFlopAndResize;
   
END ARCHITECTURE inputLRCK;



-- VHDL Entity Memory.bramDualport.symbol
--
-- Created:
--          by - maxim.UNKNOWN (DESKTOP-ADLE19A)
--          at - 12:26:57 19/07/2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    USE ieee.numeric_std.all;

ENTITY bramDualport IS
    GENERIC( 
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT( 
        clockA   : IN     std_ulogic;
        enA      : IN     std_ulogic;
        writeEnA : IN     std_ulogic;
        addressA : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInA  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutA : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        clockB   : IN     std_ulogic;
        enB      : IN     std_ulogic;
        writeEnB : IN     std_ulogic;
        addressB : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutB : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END bramDualport ;





USE std.textio.all;

ARCHITECTURE bhv OF bramDualport IS
  -- Define ramContent type
  type ramContentType is array(0 to (2**addressBitNb)-1) of bit_vector(dataBitNb-1 DOWNTO 0);

  -- Declare ramContent signal
  shared variable ramContent: ramContentType;

BEGIN
  -- Port A
  process(clockA)
  begin
    if clockA'event and clockA='1' then
      if enA = '1' then
        if writeEnA = '1' then
          dataOutA <= dataInA;
          ramContent(to_integer(unsigned(addressA))) := to_bitvector(dataInA,'0');
        else
          dataOutA <= to_stdulogicvector(ramContent(to_integer(unsigned(addressA))));
        end if;
      end if;
    end if;
  end process;

  -- Port B
  process(clockB)
  begin
    if clockB'event and clockB='1' then
      if enB = '1' then
        if writeEnB = '1' then
          ramContent(to_integer(unsigned(addressB))) := to_bitvector(dataInB,'0');
          dataOutB <= dataInB;
        else
          dataOutB <= to_stdulogicvector(ramContent(to_integer(unsigned(addressB))));
        end if;
      end if;
    end if;
  end process;

END ARCHITECTURE bhv;




-- VHDL Entity Splitter.SeialSync.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 12:54:43 27.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY SeialSync IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        DataReady   : IN     std_ulogic;
        LR_I        : IN     std_uLogic;
        NewData     : IN     std_uLogic;
        clock       : IN     std_uLogic;
        highPass    : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass     : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        reset       : IN     std_uLogic;
        audioLeft1  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight1 : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );

-- Declarations

END SeialSync ;





--------------------------------------------------------------------------------
-- ensures the syncro between the Xover and the i2s encoder 
-- also devides the highpass signal by 2 to account for the higher 
-- efficency of the tweeter
--------------------------------------------------------------------------------
ARCHITECTURE sync1 OF SeialSync IS
	signal oldR : std_ulogic;
	signal oldLR : std_ulogic;
	signal cnt : unsigned(2 downto 0);
	signal tempLow : signed(lowPass'range);
	signal tempHigh : signed(highPass'range);
BEGIN
	syncro : process (clock, reset)
	begin
		if (reset = '1') then
			oldR <= '0';
			oldLR <= '0';
			cnt <= (others => '0');
			tempHigh <= (others => '0');
			tempLow <= (others => '0');
		elsif rising_edge(clock) then
			if DataReady = '1' then
				tempLow <= lowPass;
				tempHigh <= highPass;
				tempLow(0) <= '0';
				tempLow(1) <= '0';
				tempLow(2) <= '0';
				tempHigh(0) <= '0';
				tempHigh(1) <= '0';
				tempHigh(2) <= '0';
			end if;
			audioRight1 <= tempLow;
			-- to account for the higher efficency of the twitter
			audioLeft1 <= resize(shift_right(tempHigh, 1),audioLeft1'length);
		end if;
	end process syncro;
END ARCHITECTURE sync1;



-- VHDL Entity Splitter.risingEdgeDetector.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:00:47 02.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY risingEdgeDetector IS
    PORT( 
        clock     : IN     std_logic;
        dataValid : IN     std_logic;
        reset     : IN     std_logic;
        en        : OUT    std_logic
    );

-- Declarations

END risingEdgeDetector ;





-------------------------------------------
-- detecting the risingEdge of a sinal
-------------------------------------------
ARCHITECTURE edge OF risingEdgeDetector IS

   signal signalDelayed : std_logic;

BEGIN

   delaySignal : process(clock,reset)
   begin 

   if reset = '1' then
      signalDelayed <= '0';
   elsif rising_edge(clock) then
      -- delaying the signal 
      signalDelayed <= DataValid;
   end if;
end process delaySignal;
   -- detecting the rising dege and updating the output
   en <= '1' when (DataValid = '1') and (signalDelayed = '0') else '0';
   
END ARCHITECTURE edge;





-- VHDL Entity Splitter.muxOut.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:58:06 12.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY muxOut IS
    PORT( 
        CLK_I  : IN     std_uLogic;
        DOUT   : IN     std_ulogic;
        Data_I : IN     std_uLogic;
        LRCK   : IN     std_ulogic;
        LR_I   : IN     std_uLogic;
        S20    : IN     std_ulogic;
        SCK    : IN     std_ulogic;
        CLK_O  : OUT    std_uLogic;
        Data_O : OUT    std_uLogic;
        LR_O   : OUT    std_ulogic
    );

-- Declarations

END muxOut ;





--------------------------------------------------------------------------------
-- multiplexor to switch between the modified data and the raw
--------------------------------------------------------------------------------
ARCHITECTURE TIOrFPGA OF muxOut IS
BEGIN
    Data_O <= DOUT when S20 = '0' else Data_I ;
    LR_O <= LRCK when S20 = '0' else LR_I ;
    CLK_O <= SCK when S20 = '0' else CLK_I ;
END ARCHITECTURE TIOrFPGA;





-- VHDL Entity Splitter.delayer.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 14:20:38 03.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY delayer IS
    PORT( 
        Data         : IN     std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        Data_delayed : OUT    std_logic
    );

-- Declarations

END delayer ;





-------------------------------------------------------------
-- delaying the signal to take into account the sync register 
-------------------------------------------------------------

ARCHITECTURE delay1 OF delayer IS
BEGIN
    delaySignal : process(clock,reset)
    begin 
       
        if reset = '1' then
			data_delayed <= '0';
		elsif rising_edge(clock) then
            -- delay the siganl by 1 clock period 
           data_delayed <= Data;
        end if;
    end process delaySignal;
    
END ARCHITECTURE delay1;





--
-- VHDL Architecture Splitter.leftRightSplitter.visitorsVersion
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 13:14:27 02.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

-- LIBRARY Memory;
-- LIBRARY Splitter;
-- LIBRARY Splitter_test;

ARCHITECTURE visitorsVersion OF leftRightSplitter IS

    -- Architecture declarations
    constant DATA_WIDTH : positive := 32;
    constant COEFF_BIT_NB : positive := 32;
    constant FILTER_TAP_NB : positive := 499;
    constant DATA_IN_WIDTH : positive := 32;
    constant addressBitNb :positive := 12;
    constant dataBitNb :positive := 16;
    constant initFile : string := "bramInit.txt";
    constant uartDataBitNb : positive := 8;
    constant uartBaudRate: real := 9.6E3;
    constant clockFrequency: real := 66.0E6;

    -- Internal signal declarations
    SIGNAL DOUT        : std_ulogic;
    SIGNAL Data        : std_ulogic;
    SIGNAL DataReady   : std_ulogic;
    SIGNAL Debug       : std_ulogic;
    SIGNAL DebugData   : unsigned(1 DOWNTO 0);
    SIGNAL Frameout0   : std_uLogic;
    SIGNAL LRCK        : std_ulogic;
    SIGNAL NewData     : std_uLogic;
    SIGNAL Next_data   : std_ulogic;
    SIGNAL RS232Data   : std_ulogic_vector(uartDataBitNb-1 DOWNTO 0);
    SIGNAL RS232Valid  : std_ulogic;
    SIGNAL SCK         : std_ulogic;
    SIGNAL addressB    : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL addressB1   : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL audioLeft   : signed(DATA_IN_WIDTH-1 DOWNTO 0);
    SIGNAL audioLeft1  : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL audioRight  : signed(DATA_IN_WIDTH-1 DOWNTO 0);
    SIGNAL audioRight1 : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL audio_R_out : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL dataInB     : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataOutA    : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataOutB    : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dataValid   : std_ulogic;
    SIGNAL din         : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL en          : std_logic;
    SIGNAL enB         : std_ulogic;
    SIGNAL enB1        : std_ulogic;
    SIGNAL end_Calc    : std_ulogic;
    SIGNAL highPass    : signed(DATA_WIDTH-1  DOWNTO  0);
    SIGNAL lowPass     : signed(DATA_WIDTH-1  DOWNTO  0);
    SIGNAL rdaddr      : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL re          : std_ulogic;
    SIGNAL we          : std_ulogic;
    SIGNAL wraddr      : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL writeEnA    : std_ulogic;
    SIGNAL writeEnB    : std_ulogic;
    SIGNAL writeEnB1   : std_ulogic;


    -- Component Declarations
    COMPONENT bramDualport
    GENERIC (
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT (
        clockA   : IN     std_ulogic ;
        enA      : IN     std_ulogic ;
        writeEnA : IN     std_ulogic ;
        addressA : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInA  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutA : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        clockB   : IN     std_ulogic ;
        enB      : IN     std_ulogic ;
        writeEnB : IN     std_ulogic ;
        addressB : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutB : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT CoeffWriter
    GENERIC (
        addressBitNb  : positive;
        dataBitNb     : positive;
        FILTER_TAP_NB : positive;
        COEFF_BIT_NB  : positive;
        DATA_WIDTH    : positive
    );
    PORT (
        clock    : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        addressB : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        enB      : OUT    std_ulogic ;
        writeEnB : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT RAMmultiplexer
    GENERIC (
        addressBitNb : positive
    );
    PORT (
        addressB  : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        enB       : IN     std_ulogic ;
        rdaddr    : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re        : IN     std_ulogic ;
        writeEnB  : IN     std_ulogic ;
        addressB1 : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        enB1      : OUT    std_ulogic ;
        writeEnB1 : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT RS232_reciver
    GENERIC (
        uartDataBitNb  : positive;
        baudRateDivide : positive
    );
    PORT (
        RxD        : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        reset      : IN     std_ulogic ;
        RS232Data  : OUT    std_ulogic_vector (uartDataBitNb-1 DOWNTO 0);
        RS232Valid : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT SeialSync
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        DataReady   : IN     std_ulogic ;
        LR_I        : IN     std_uLogic ;
        NewData     : IN     std_uLogic ;
        clock       : IN     std_uLogic ;
        highPass    : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass     : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        reset       : IN     std_uLogic ;
        audioLeft1  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight1 : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT Xover_with_RAM
    GENERIC (
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive;
        COEFF_BIT_NB  : positive;
        dataBitNb     : positive;
        addressBitNb  : positive
    );
    PORT (
        DataInCoeffs : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        audio_In     : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock        : IN     std_ulogic ;
        dout1        : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        en           : IN     std_logic ;
        reset        : IN     std_ulogic ;
        DataReady    : OUT    std_ulogic ;
        DebugData    : OUT    unsigned (1 DOWNTO 0);
        din          : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        highPass     : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass      : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        rdaddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re           : OUT    std_ulogic ;
        we           : OUT    std_ulogic ;
        wraddr       : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        writeEnA     : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT delayer
    PORT (
        Data         : IN     std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        Data_delayed : OUT    std_logic 
    );
    END COMPONENT;
    COMPONENT iisDecoder
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        reset      : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        LRCK       : IN     std_ulogic ;
        SCK        : IN     std_ulogic ;
        DOUT       : IN     std_ulogic ;
        dataValid  : OUT    std_ulogic ;
        audioLeft  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        lr2        : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT iisEncoder
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        reset      : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        audioLeft  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        LRCK       : OUT    std_ulogic ;
        SCK        : OUT    std_ulogic ;
        DOUT       : OUT    std_ulogic ;
        CLKI2s     : IN     std_uLogic ;
        LRCK1      : IN     std_uLogic ;
        NewData    : OUT    std_uLogic ;
        Frameout0  : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT muxOut
    PORT (
        CLK_I  : IN     std_uLogic ;
        DOUT   : IN     std_ulogic ;
        Data_I : IN     std_uLogic ;
        LRCK   : IN     std_ulogic ;
        LR_I   : IN     std_uLogic ;
        S20    : IN     std_ulogic ;
        SCK    : IN     std_ulogic ;
        CLK_O  : OUT    std_uLogic ;
        Data_O : OUT    std_uLogic ;
        LR_O   : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT risingEdgeDetector
    PORT (
        clock     : IN     std_logic ;
        dataValid : IN     std_logic ;
        reset     : IN     std_logic ;
        en        : OUT    std_logic 
    );
    END COMPONENT;
    COMPONENT testerRS232
    GENERIC (
        uartDataBitNb : positive
    );
    PORT (
        RS232Data  : IN     std_ulogic_vector (uartDataBitNb -1 DOWNTO 0);
        RS232Valid : IN     std_ulogic ;
        Debug      : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT bascule
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        audio_L_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock       : IN     std_ulogic ;
        dataVAlid   : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        audio_L_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : CoeffWriter USE ENTITY Splitter.CoeffWriter;
--     FOR ALL : RAMmultiplexer USE ENTITY Splitter.RAMmultiplexer;
--     FOR ALL : RS232_reciver USE ENTITY Splitter.RS232_reciver;
--     FOR ALL : SeialSync USE ENTITY Splitter.SeialSync;
--     FOR ALL : Xover_with_RAM USE ENTITY Splitter.Xover_with_RAM;
--     FOR ALL : bascule USE ENTITY Splitter_test.bascule;
--     FOR ALL : bramDualport USE ENTITY Memory.bramDualport;
--     FOR ALL : delayer USE ENTITY Splitter.delayer;
--     FOR ALL : iisDecoder USE ENTITY Splitter.iisDecoder;
--     FOR ALL : iisEncoder USE ENTITY Splitter.iisEncoder;
--     FOR ALL : muxOut USE ENTITY Splitter.muxOut;
--     FOR ALL : risingEdgeDetector USE ENTITY Splitter.risingEdgeDetector;
--     FOR ALL : testerRS232 USE ENTITY Splitter.testerRS232;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    testOut(0) <= DebugData(0);
    testOut(1) <= DebugData(1);
    testOut(2) <= RxD_synch;
    testOut(3) <= RS232Valid;
    testOut(4) <= DebugData(0);
    testOut(5) <= DebugData(1);
    testOut(6) <= DebugData(1);


    -- Instance port mappings.
    I3 : bramDualport
        GENERIC MAP (
            addressBitNb => addressBitNb,
            dataBitNb    => dataBitNb,
            initFile     => initFile
        )
        PORT MAP (
            clockA   => clock,
            enA      => we,
            writeEnA => writeEnA,
            addressA => wraddr,
            dataInA  => din,
            dataOutA => dataOutA,
            clockB   => clock,
            enB      => enB1,
            writeEnB => writeEnB1,
            addressB => addressB1,
            dataInB  => dataInB,
            dataOutB => dataOutB
        );
    I10 : CoeffWriter
        GENERIC MAP (
            addressBitNb  => 	addressBitNb,
            dataBitNb     => dataBitNb,
            FILTER_TAP_NB => FILTER_TAP_NB,
            COEFF_BIT_NB  => COEFF_BIT_NB,
            DATA_WIDTH    => DATA_WIDTH
        )
        PORT MAP (
            clock    => clock,
            reset    => reset,
            addressB => addressB,
            dataInB  => dataInB,
            enB      => enB,
            writeEnB => writeEnB
        );
    I12 : RAMmultiplexer
        GENERIC MAP (
            addressBitNb => addressBitNb
        )
        PORT MAP (
            addressB  => addressB,
            enB       => enB,
            rdaddr    => rdaddr,
            re        => re,
            writeEnB  => writeEnB,
            addressB1 => addressB1,
            enB1      => enB1,
            writeEnB1 => writeEnB1
        );
    I13 : RS232_reciver
        GENERIC MAP (
            uartDataBitNb  => uartDataBitNb,
            baudRateDivide => integer(clockFrequency/uartBaudRate + 0.5)
        )
        PORT MAP (
            RxD        => RxD_synch,
            clock      => clock,
            reset      => reset,
            RS232Data  => RS232Data,
            RS232Valid => RS232Valid
        );
    I4 : SeialSync
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            DataReady   => end_Calc,
            LR_I        => LR_I,
            NewData     => Next_data,
            clock       => clock,
            highPass    => highPass,
            lowPass     => lowPass,
            reset       => reset,
            audioLeft1  => audioLeft1,
            audioRight1 => audioRight1
        );
    I11 : Xover_with_RAM
        GENERIC MAP (
            DATA_WIDTH    => DATA_WIDTH,
            FILTER_TAP_NB => FILTER_TAP_NB,
            COEFF_BIT_NB  => COEFF_BIT_NB,
            dataBitNb     => dataBitNb,
            addressBitNb  => addressBitNb
        )
        PORT MAP (
            DataInCoeffs => dataOutB,
            audio_In     => audio_R_out,
            clock        => clock,
            dout1        => dataOutA,
            en           => en,
            reset        => reset,
            DataReady    => DataReady,
            DebugData    => DebugData,
            din          => din,
            highPass     => highPass,
            lowPass      => lowPass,
            rdaddr       => rdaddr,
            re           => re,
            we           => we,
            wraddr       => wraddr,
            writeEnA     => writeEnA
        );
    I9 : delayer
        PORT MAP (
            Data         => Data,
            clock        => clock,
            reset        => reset,
            Data_delayed => en
        );
    I0 : iisDecoder
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            reset      => reset,
            clock      => clock,
            LRCK       => LR_I,
            SCK        => CLK_I,
            DOUT       => Data_I,
            dataValid  => dataValid,
            audioLeft  => audioLeft,
            audioRight => audioRight,
            lr2        => OPEN
        );
    I2 : iisEncoder
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            reset      => reset,
            clock      => clock,
            audioLeft  => audioLeft1,
            audioRight => audioRight1,
            LRCK       => LRCK,
            SCK        => SCK,
            DOUT       => DOUT,
            CLKI2s     => CLK_I,
            LRCK1      => LR_I,
            NewData    => NewData,
            Frameout0  => Frameout0
        );
    I8 : muxOut
        PORT MAP (
            CLK_I  => CLK_I,
            DOUT   => DOUT,
            Data_I => Data_I,
            LRCK   => LRCK,
            LR_I   => LR_I,
            S20    => S20,
            SCK    => SCK,
            CLK_O  => CLK_O,
            Data_O => Data_O,
            LR_O   => LR_O
        );
    I5 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => dataValid,
            reset     => reset,
            en        => Data
        );
    I6 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => DataReady,
            reset     => reset,
            en        => end_Calc
        );
    I7 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => NewData,
            reset     => reset,
            en        => Next_data
        );
    I14 : testerRS232
        GENERIC MAP (
            uartDataBitNb => uartDataBitNb
        )
        PORT MAP (
            RS232Data  => RS232Data,
            RS232Valid => RS232Valid,
            Debug      => Debug
        );
    I1 : bascule
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            audio_L_in  => audioRight,
            audio_R_in  => audioLeft,
            clock       => clock,
            dataVAlid   => Data,
            reset       => reset,
            audio_L_out => OPEN,
            audio_R_out => audio_R_out
        );

END visitorsVersion;




-- VHDL Entity gates.inverter.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY inverter IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverter ;





ARCHITECTURE sim OF inverter IS
BEGIN
  out1 <= NOT in1 after delay;
END sim;




-- VHDL Entity gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




-- VHDL Entity sequential.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY DFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0' after delay;
    elsif rising_edge(clk) then
      q <= d after delay;
    end if;
  end process;

END sim;




--
-- VHDL Architecture Board.FPGA_splitter.struct
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:34:42 02.08.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

-- LIBRARY sequential;
-- LIBRARY Splitter;

ARCHITECTURE struct OF FPGA_splitter IS

    -- Architecture declarations
    constant clockFrequency: real := 66.0E6;
    constant rs232BaudRate: real := 115.2E3;
    constant pwmFrequency: real := 100.0E3;
    constant mainsFrequency: real := 50.0;
    constant debounceCounterBitNb: positive := requiredBitNb(integer(clockFrequency/100.0));
    constant spikeFilterCounterBitNb: positive := requiredBitNb(10);
    constant buttonsRepeatFrequency: real := 100.0;
    constant controlAmplitudeBitNb: natural := 10;
    constant proportionalShift: integer := -14;
    constant integratorShift: integer := -12;
    constant testLineNb: positive := 16;

    -- Internal signal declarations
    SIGNAL CLK_I        : std_uLogic;
    SIGNAL CLK_O1       : std_uLogic;
    SIGNAL Data_I       : std_uLogic;
    SIGNAL Data_O1      : std_uLogic;
    SIGNAL LR_I         : std_uLogic;
    SIGNAL LR_O1        : std_ulogic;
    SIGNAL RxD_synch    : std_uLogic;
    SIGNAL reset        : std_ulogic;
    SIGNAL reset1       : std_ulogic;
    SIGNAL resetSynch   : std_ulogic;
    SIGNAL resetSynch_n : std_ulogic;


    -- Component Declarations
    COMPONENT inverter
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT DFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT leftRightSplitter
    GENERIC (
        signalBitNb  : positive := 24;
        signalOBitNb : positive := 32
    );
    PORT (
        CLK_I     : IN     std_uLogic ;
        Data_I    : IN     std_uLogic ;
        LR_I      : IN     std_uLogic ;
        RxD_synch : IN     std_ulogic ;
        S20       : IN     std_ulogic ;
        S21       : IN     std_ulogic ;
        S22       : IN     std_ulogic ;
        S23       : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        CLK_O     : OUT    std_uLogic ;
        Data_O    : OUT    std_uLogic ;
        LR_O      : OUT    std_ulogic ;
        testOut   : OUT    std_ulogic_vector (6 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF USE ENTITY sequential.DFF;
--     FOR ALL : inverter USE ENTITY gates.inverter;
--     FOR ALL : leftRightSplitter USE ENTITY Splitter.leftRightSplitter;
--     FOR ALL : logic1 USE ENTITY gates.logic1;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I1 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => reset_n,
            out1 => reset
        );
    I7 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => resetSynch_n,
            out1 => resetSynch
        );
    I28 : logic1
        PORT MAP (
            logic_1 => reset1
        );
    I_rst : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => reset1,
            Q   => resetSynch_n
        );
    I_rst1 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => LR_In,
            Q   => LR_I
        );
    I_rst2 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => Data_In,
            Q   => Data_I
        );
    I_rst3 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => CLK_In,
            Q   => CLK_I
        );
    I_rst4 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => Data_O1,
            Q   => Data_O
        );
    I_rst5 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => CLK_O1,
            Q   => CLK_O
        );
    I_rst6 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => LR_O1,
            Q   => LR_O
        );
    I_rst7 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => RxD,
            Q   => RxD_synch
        );
    I0 : leftRightSplitter
        GENERIC MAP (
            signalBitNb  => 24,
            signalOBitNb => 32
        )
        PORT MAP (
            CLK_I     => CLK_I,
            Data_I    => Data_I,
            LR_I      => LR_I,
            RxD_synch => RxD_synch,
            S20       => S20,
            S21       => S21,
            S22       => S22,
            S23       => S23,
            clock     => clock,
            reset     => resetSynch,
            CLK_O     => CLK_O1,
            Data_O    => Data_O1,
            LR_O      => LR_O1,
            testOut   => testOut
        );

END struct;




