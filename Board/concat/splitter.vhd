-- VHDL Entity Board.FPGA_splitter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:18:08 30.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FPGA_splitter IS
    GENERIC( 
        buttonNb : positive := 4;
        ledNb    : positive := 8
    );
    PORT( 
        CLK_In  : IN     std_uLogic;
        Data_In : IN     std_uLogic;
        LR_In   : IN     std_uLogic;
        S20     : IN     std_ulogic;
        S21     : IN     std_ulogic;
        S22     : IN     std_ulogic;
        S23     : IN     std_ulogic;
        S30     : IN     std_ulogic;
        S31     : IN     std_ulogic;
        S32     : IN     std_ulogic;
        S33     : IN     std_ulogic;
        S40     : IN     std_ulogic;
        S41     : IN     std_ulogic;
        S42     : IN     std_ulogic;
        S43     : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset_n : IN     std_ulogic;
        CLK_O   : OUT    std_uLogic;
        Data_O  : OUT    std_uLogic;
        LR_O    : OUT    std_ulogic;
        testOut : OUT    std_ulogic_vector (6 DOWNTO 0)
    );

-- Declarations

END FPGA_splitter ;





-- VHDL Entity Splitter.leftRightSplitter.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 13:11:02 04.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY leftRightSplitter IS
    GENERIC( 
        signalBitNb  : positive := 24;
        signalOBitNb : positive := 32
    );
    PORT( 
        CLK_I   : IN     std_uLogic;
        Data_I  : IN     std_uLogic;
        LR_I    : IN     std_uLogic;
        S20     : IN     std_ulogic;
        S21     : IN     std_ulogic;
        S22     : IN     std_ulogic;
        S23     : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        CLK_O   : OUT    std_uLogic;
        Data_O  : OUT    std_uLogic;
        LR_O    : OUT    std_ulogic;
        testOut : OUT    std_ulogic_vector (6 DOWNTO 0)
    );

-- Declarations

END leftRightSplitter ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




-- VHDL Entity Splitter.iisDecoder.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:36:01 23.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY iisDecoder IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        reset      : IN     std_ulogic;
        clock      : IN     std_ulogic;
        LRCK       : IN     std_ulogic;
        SCK        : IN     std_ulogic;
        DOUT       : IN     std_ulogic;
        dataValid  : OUT    std_ulogic;
        audioLeft  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        lr2        : OUT    std_ulogic
    );

-- Declarations

END iisDecoder ;





--
-- VHDL Architecture Splitter.iisDecoder.MYArchi
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:49:17 13.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE MYArchi OF iisDecoder IS

    signal sckDelayed, sckRising, sckFalling : std_ulogic;
    signal lrckDelayed, lrckChanged : std_ulogic;

    signal oldLRCK : std_ulogic;
    signal oldSCK : std_ulogic;
--    signal oldSCK1 : std_ulogic;
    signal lrSel1, lrSel : std_ulogic;
    signal lrCounter1, lrCounter : unsigned(4 downto 0);  -- count to 32
    

BEGIN

    delaySck: process(reset, clock)
	begin
		if reset = '1' then
			sckDelayed <= '0';
            lrckDelayed <= '0';
		elsif rising_edge(clock) then
            sckDelayed <= SCK;
            lrckDelayed <= LRCK;
        end if;
    end process delaySck;

    sckRising <= '1' when (SCK = '1') and (sckDelayed = '0')
        else '0';

    sckFalling <= '1' when (SCK = '0') and (sckDelayed = '1')
        else '0';

    lrckChanged <= '1' when LRCK /= lrckDelayed
        else '0';

    countBits: process(reset, clock)
	begin
		if reset = '1' then
			lrCounter1 <= (others => '1');
			lrCounter <= (others => '1');
		elsif rising_edge(clock) then

            if lrckChanged = '1' then 
                lrCounter1 <= (others => '1');
            elsif sckRising = '1' then 
                lrCounter1 <= lrCounter1 - 1;
            end if ;
            
            if sckFalling = '1' then 
                lrCounter <= lrCounter1 + 1;
            end if ;

        end if;
    end process countBits;

    shiftLrSel: process(reset, clock)
	begin
		if reset = '1' then
			lrSel1 <= '0';
			lrSel <= '0';
		elsif rising_edge(clock) then
            if sckRising = '1' then 
                lrSel1 <= LRCK;
            elsif sckFalling = '1' then 
                lrSel <= lrSel1;
            end if ;
        end if;
    end process shiftLrSel;

    fillReg : process(clock , reset )
    begin
       
        if reset = '1' then
            audioLeft <= (others => '0');
            audioRight <= (others => '0');
		elsif rising_edge(clock) then
            if sckRising = '1' then 
                if lrSel = '1' then 
                    audioLeft(to_integer(lrCounter)) <= DOUT;
                else
                    audioRight(to_integer(lrCounter)) <= DOUT;
                end if;
            end if ; 
        end if;
    end process fillReg;

    lr2 <= lrSel;
  dataValid <= '1' when  lrCounter = 0 and SCK = '1' and LRCK = '1' else '0';     
    --dataValid <= '1' when  lrCounter = 0 and SCK = '1' else '0';         
END ARCHITECTURE MYArchi;




-- VHDL Entity Splitter_test.bascule.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:27:20 09.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY bascule IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        audio_L_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock       : IN     std_ulogic;
        dataVAlid   : IN     std_ulogic;
        reset       : IN     std_ulogic;
        audio_L_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );

-- Declarations

END bascule ;





--
-- VHDL Architecture Splitter_test.bascule.test_lowpas_i2s
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:08:13 30.05.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE test_lowpas_i2s OF bascule IS

 signal cnt :  unsigned (2 downto 0);

BEGIN

    FlipFlopAndResize: process(reset, clock)
	begin
		if reset = '1' then
			audio_R_out <= (others => '0');
            audio_L_out <= (others => '0');
            cnt <= (others => '0');
		elsif rising_edge(clock) then
            -- if dataValid = '1' then
                -- cnt <= cnt + 1;
            -- end if;
            -- if cnt = 2 then 
                -- cnt <= (others => '0');
                -- audio_R_out <= audio_R_in;
                -- audio_L_out <= audio_L_in;
            -- end if ;
            if dataValid = '1' then
               audio_R_out <= audio_R_in;
               audio_L_out <= audio_L_in;      
            end if;

                      
		end if;
	end process FlipFlopAndResize;



END ARCHITECTURE test_lowpas_i2s;





-- VHDL Entity Splitter.HighLevel.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 14:25:51 14.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY HighLevel IS
    GENERIC( 
        dataBitNb : positive
    );
    PORT( 
        dataInB  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        writeEnA : OUT    std_ulogic;
        writeEnB : OUT    std_ulogic
    );

-- Declarations

END HighLevel ;





--
-- VHDL Architecture Splitter.HighLevel.HighLevel
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 14:12:04 14.07.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE HighLevel OF HighLevel IS
BEGIN
    writeEnA <= '1'; 
    writeENB <= '0';
    dataInB <= "0000000000000000";
END ARCHITECTURE HighLevel;





-- VHDL Entity Splitter.Xover_with_RAM.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 16:04:21 14.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY Xover_with_RAM IS
    GENERIC( 
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive;
        COEFF_BIT_NB  : positive;
        dataBitNb     : positive;
        addressBitNb  : positive
    );
    PORT( 
        audio_In  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock     : IN     std_ulogic;
        dout1     : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        en        : IN     std_logic;
        reset     : IN     std_ulogic;
        DataReady : OUT    std_ulogic;
        DebugData : OUT    unsigned (1 DOWNTO 0);
        din       : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        highPass  : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass   : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        rdaddr    : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re        : OUT    std_ulogic;
        we        : OUT    std_ulogic;
        wraddr    : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0)
    );

-- Declarations

END Xover_with_RAM ;





--
-- VHDL Architecture Splitter.Xover_with_RAM.FirstArchi
--
-- Created:
--          by - maxim.UNKNOWN (DESKTOP-ADLE19A)
--          at - 12:11:17 12/07/2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE FirstArchi OF Xover_with_RAM IS
 --constant HALF_FILTER_TAP_NB: positive := FILTER_TAP_NB/2 + (FILTER_TAP_NB mod 2);
    constant FINAL_SHIFT : positive := requiredBitNb(FILTER_TAP_NB);
    constant ACCUMULATOR_Bit_NB: positive := COEFF_BIT_NB + audio_In'length + FINAL_SHIFT  ;  
   
   
    signal debug :signed(ACCUMULATOR_Bit_NB-1 DOWNTO 0);
    -- +1 because it is symetrical we add two samples together
   
    type   t_samples is array (0 to FILTER_TAP_NB-1) of signed (audio_In'range);  -- vector of FILTER_TAP_NB signed elements
    signal samples : t_samples ; 
    signal oldLRCK : std_ulogic;
    
    signal calculate  : unsigned (2 downto 0);
    signal calculatedelayed  : unsigned (2 downto 0);
    signal cnt   : unsigned(FINAL_SHIFT-1 DOWNTO 0);
    signal cnt2 :  unsigned (2 downto 0);
    signal sum_v : signed(audio_In'length downto 0) := (others=>'0');
    signal mul_v1 : signed(audio_In'length+COEFF_BIT_NB downto 0) := (others=>'0');
    signal mul_v2: signed(audio_In'length+COEFF_BIT_NB downto 0) := (others=>'0');
    signal selector :unsigned (2 downto 0);
    --signal accumulator : signed (ACCUMULATOR_Bit_NB-1 DOWNTO 0);
-- RAM oriented variables ----------------------------------------------------
    signal firstWrite : std_ulogic;
    signal cntNooffset :  unsigned(dataBitNb downto 0);
    signal firstRead :  unsigned(3 downto 0);
    signal wAddrCnt : unsigned(addressBitNb-1 downto 0);
    signal rAddrCnt_Plus : unsigned(addressBitNb-1 downto 0);
    signal rAddrCnt_Minus : unsigned(addressBitNb-1 downto 0);
    signal initialRAddress : unsigned(addressBitNb-1 downto 0);
    signal RAMfull : std_ulogic;
    signal RAMfulldelayed : std_ulogic;
    constant n: positive := 1 ;     
    constant initialWAddress : natural := 0;
    signal temp1 :  signed (audio_In'range); 
    signal sample1 :  signed (audio_In'range);
    constant RAMLength : positive := (((FILTER_TAP_NB * n * 2) + initialWAddress) -1);     
    
    -- lowpass firtst then highpass coeff
    type coefficients is array (0 to 1,0 to FILTER_TAP_NB-1) of signed( COEFF_BIT_NB-1 downto 0);
    signal coeff: coefficients :=(
    ( 
        x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"0000", 
x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"FFFF", 
x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"0000", 
x"0001", x"0001", x"0001", x"0002", x"0002", x"0001", x"0001", x"0000", x"FFFF", x"FFFF", 
x"FFFF", x"FFFE", x"FFFD", x"FFFD", x"FFFE", x"FFFE", x"FFFF", x"FFFF", x"0000", x"0002", 
x"0003", x"0004", x"0004", x"0004", x"0004", x"0003", x"0001", x"0000", x"FFFF", x"FFFD", 
x"FFFB", x"FFFA", x"FFFA", x"FFFA", x"FFFB", x"FFFD", x"FFFF", x"0000", x"0003", x"0005", 
x"0007", x"0008", x"0008", x"0007", x"0006", x"0003", x"0000", x"FFFE", x"FFFB", x"FFF8", 
x"FFF6", x"FFF5", x"FFF5", x"FFF7", x"FFF9", x"FFFD", x"0000", x"0005", x"0009", x"000C", 
x"000E", x"000F", x"000E", x"000B", x"0007", x"0002", x"FFFD", x"FFF7", x"FFF3", x"FFEF", 
x"FFED", x"FFED", x"FFEF", x"FFF4", x"FFFA", x"0000", x"0007", x"000E", x"0013", x"0017", 
x"0019", x"0017", x"0013", x"000D", x"0005", x"FFFD", x"FFF4", x"FFEB", x"FFE5", x"FFE2", 
x"FFE1", x"FFE4", x"FFEA", x"FFF3", x"FFFE", x"0009", x"0014", x"001D", x"0024", x"0027", 
x"0025", x"0020", x"0017", x"000B", x"FFFE", x"FFEF", x"FFE2", x"FFD8", x"FFD2", x"FFD0", 
x"FFD4", x"FFDC", x"FFE9", x"FFFA", x"000A", x"001B", x"002A", x"0035", x"003B", x"003A", 
x"0033", x"0026", x"0014", x"0000", x"FFEB", x"FFD7", x"FFC6", x"FFBB", x"FFB7", x"FFBB", 
x"FFC7", x"FFD9", x"FFF1", x"000A", x"0024", x"003C", x"004D", x"0057", x"0058", x"0050", 
x"003E", x"0024", x"0006", x"FFE6", x"FFC7", x"FFAD", x"FF9B", x"FF93", x"FF96", x"FFA5", 
x"FFBF", x"FFE1", x"0008", x"002F", x"0054", x"0071", x"0083", x"0088", x"007D", x"0065", 
x"0041", x"0013", x"FFE2", x"FFB2", x"FF87", x"FF68", x"FF57", x"FF59", x"FF6C", x"FF91", 
x"FFC4", x"0000", x"003F", x"007B", x"00AD", x"00CE", x"00DB", x"00D1", x"00AF", x"0077", 
x"0030", x"FFDF", x"FF8C", x"FF41", x"FF06", x"FEE2", x"FEDC", x"FEF5", x"FF2E", x"FF82", 
x"FFEA", x"005C", x"00CE", x"0133", x"017E", x"01A5", x"01A1", x"016E", x"010D", x"0084", 
x"FFDD", x"FF26", x"FE72", x"FDD3", x"FD5E", x"FD25", x"FD37", x"FD9E", x"FE60", x"FF79", 
x"00E1", x"0289", x"045D", x"0643", x"081E", x"09D4", x"0B49", x"0C66", x"0D18", x"0D55", 
x"0D18", x"0C66", x"0B49", x"09D4", x"081E", x"0643", x"045D", x"0289", x"00E1", x"FF79", 
x"FE60", x"FD9E", x"FD37", x"FD25", x"FD5E", x"FDD3", x"FE72", x"FF26", x"FFDD", x"0084", 
x"010D", x"016E", x"01A1", x"01A5", x"017E", x"0133", x"00CE", x"005C", x"FFEA", x"FF82", 
x"FF2E", x"FEF5", x"FEDC", x"FEE2", x"FF06", x"FF41", x"FF8C", x"FFDF", x"0030", x"0077", 
x"00AF", x"00D1", x"00DB", x"00CE", x"00AD", x"007B", x"003F", x"0000", x"FFC4", x"FF91", 
x"FF6C", x"FF59", x"FF57", x"FF68", x"FF87", x"FFB2", x"FFE2", x"0013", x"0041", x"0065", 
x"007D", x"0088", x"0083", x"0071", x"0054", x"002F", x"0008", x"FFE1", x"FFBF", x"FFA5", 
x"FF96", x"FF93", x"FF9B", x"FFAD", x"FFC7", x"FFE6", x"0006", x"0024", x"003E", x"0050", 
x"0058", x"0057", x"004D", x"003C", x"0024", x"000A", x"FFF1", x"FFD9", x"FFC7", x"FFBB", 
x"FFB7", x"FFBB", x"FFC6", x"FFD7", x"FFEB", x"0000", x"0014", x"0026", x"0033", x"003A", 
x"003B", x"0035", x"002A", x"001B", x"000A", x"FFFA", x"FFE9", x"FFDC", x"FFD4", x"FFD0", 
x"FFD2", x"FFD8", x"FFE2", x"FFEF", x"FFFE", x"000B", x"0017", x"0020", x"0025", x"0027", 
x"0024", x"001D", x"0014", x"0009", x"FFFE", x"FFF3", x"FFEA", x"FFE4", x"FFE1", x"FFE2", 
x"FFE5", x"FFEB", x"FFF4", x"FFFD", x"0005", x"000D", x"0013", x"0017", x"0019", x"0017", 
x"0013", x"000E", x"0007", x"0000", x"FFFA", x"FFF4", x"FFEF", x"FFED", x"FFED", x"FFEF", 
x"FFF3", x"FFF7", x"FFFD", x"0002", x"0007", x"000B", x"000E", x"000F", x"000E", x"000C", 
x"0009", x"0005", x"0000", x"FFFD", x"FFF9", x"FFF7", x"FFF5", x"FFF5", x"FFF6", x"FFF8", 
x"FFFB", x"FFFE", x"0000", x"0003", x"0006", x"0007", x"0008", x"0008", x"0007", x"0005", 
x"0003", x"0000", x"FFFF", x"FFFD", x"FFFB", x"FFFA", x"FFFA", x"FFFA", x"FFFB", x"FFFD", 
x"FFFF", x"0000", x"0001", x"0003", x"0004", x"0004", x"0004", x"0004", x"0003", x"0002", 
x"0000", x"FFFF", x"FFFF", x"FFFE", x"FFFE", x"FFFD", x"FFFD", x"FFFE", x"FFFF", x"FFFF", 
x"FFFF", x"0000", x"0001", x"0001", x"0002", x"0002", x"0001", x"0001", x"0001", x"0000", 
x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", 
x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", 
x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF"
   ),
   ( 
   x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", 
x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"0000", 
x"0000", x"0000", x"0001", x"0001", x"0001", x"0001", x"0000", x"0000", x"0000", x"FFFF", 
x"FFFF", x"FFFF", x"FFFF", x"FFFE", x"FFFE", x"FFFF", x"FFFF", x"FFFF", x"0000", x"0001", 
x"0001", x"0002", x"0003", x"0003", x"0002", x"0002", x"0001", x"0000", x"FFFF", x"FFFE", 
x"FFFD", x"FFFC", x"FFFC", x"FFFC", x"FFFC", x"FFFD", x"FFFF", x"0000", x"0001", x"0003", 
x"0005", x"0006", x"0006", x"0006", x"0005", x"0003", x"0001", x"FFFF", x"FFFD", x"FFFB", 
x"FFF9", x"FFF8", x"FFF8", x"FFF9", x"FFFA", x"FFFD", x"FFFF", x"0002", x"0005", x"0008", 
x"000A", x"000B", x"000B", x"0009", x"0007", x"0003", x"FFFF", x"FFFB", x"FFF7", x"FFF4", 
x"FFF2", x"FFF1", x"FFF2", x"FFF5", x"FFF9", x"FFFE", x"0003", x"0009", x"000D", x"0011", 
x"0013", x"0013", x"0011", x"000C", x"0006", x"0000", x"FFF9", x"FFF2", x"FFED", x"FFE9", 
x"FFE7", x"FFE9", x"FFED", x"FFF3", x"FFFB", x"0003", x"000C", x"0015", x"001B", x"001E", 
x"001F", x"001C", x"0016", x"000D", x"0002", x"FFF7", x"FFEC", x"FFE3", x"FFDC", x"FFD9", 
x"FFDB", x"FFE0", x"FFE9", x"FFF5", x"0002", x"0011", x"001E", x"0028", x"002E", x"0030", 
x"002C", x"0024", x"0017", x"0006", x"FFF6", x"FFE5", x"FFD6", x"FFCB", x"FFC5", x"FFC6", 
x"FFCD", x"FFDA", x"FFEC", x"0000", x"0015", x"0029", x"003A", x"0045", x"0049", x"0045", 
x"0039", x"0027", x"000F", x"FFF6", x"FFDC", x"FFC4", x"FFB3", x"FFA9", x"FFA8", x"FFB0", 
x"FFC2", x"FFDC", x"FFFA", x"001A", x"0039", x"0053", x"0065", x"006D", x"006A", x"005B", 
x"0041", x"001F", x"FFF8", x"FFD1", x"FFAC", x"FF8F", x"FF7D", x"FF78", x"FF83", x"FF9B", 
x"FFBF", x"FFED", x"001E", x"004E", x"0079", x"0098", x"00A9", x"00A7", x"0094", x"006F", 
x"003C", x"0000", x"FFC1", x"FF85", x"FF53", x"FF32", x"FF25", x"FF2F", x"FF51", x"FF89", 
x"FFD0", x"0021", x"0074", x"00BF", x"00FA", x"011E", x"0124", x"010B", x"00D2", x"007E", 
x"0016", x"FFA4", x"FF32", x"FECD", x"FE82", x"FE5B", x"FE5F", x"FE92", x"FEF3", x"FF7C", 
x"0023", x"00DA", x"018E", x"022D", x"02A2", x"02DB", x"02C9", x"0262", x"01A0", x"0087", 
x"FF1F", x"FD77", x"FBA3", x"F9BD", x"F7E2", x"F62C", x"F4B7", x"F39A", x"F2E8", x"72AA", 
x"F2E8", x"F39A", x"F4B7", x"F62C", x"F7E2", x"F9BD", x"FBA3", x"FD77", x"FF1F", x"0087", 
x"01A0", x"0262", x"02C9", x"02DB", x"02A2", x"022D", x"018E", x"00DA", x"0023", x"FF7C", 
x"FEF3", x"FE92", x"FE5F", x"FE5B", x"FE82", x"FECD", x"FF32", x"FFA4", x"0016", x"007E", 
x"00D2", x"010B", x"0124", x"011E", x"00FA", x"00BF", x"0074", x"0021", x"FFD0", x"FF89", 
x"FF51", x"FF2F", x"FF25", x"FF32", x"FF53", x"FF85", x"FFC1", x"0000", x"003C", x"006F", 
x"0094", x"00A7", x"00A9", x"0098", x"0079", x"004E", x"001E", x"FFED", x"FFBF", x"FF9B", 
x"FF83", x"FF78", x"FF7D", x"FF8F", x"FFAC", x"FFD1", x"FFF8", x"001F", x"0041", x"005B", 
x"006A", x"006D", x"0065", x"0053", x"0039", x"001A", x"FFFA", x"FFDC", x"FFC2", x"FFB0", 
x"FFA8", x"FFA9", x"FFB3", x"FFC4", x"FFDC", x"FFF6", x"000F", x"0027", x"0039", x"0045", 
x"0049", x"0045", x"003A", x"0029", x"0015", x"0000", x"FFEC", x"FFDA", x"FFCD", x"FFC6", 
x"FFC5", x"FFCB", x"FFD6", x"FFE5", x"FFF6", x"0006", x"0017", x"0024", x"002C", x"0030", 
x"002E", x"0028", x"001E", x"0011", x"0002", x"FFF5", x"FFE9", x"FFE0", x"FFDB", x"FFD9", 
x"FFDC", x"FFE3", x"FFEC", x"FFF7", x"0002", x"000D", x"0016", x"001C", x"001F", x"001E", 
x"001B", x"0015", x"000C", x"0003", x"FFFB", x"FFF3", x"FFED", x"FFE9", x"FFE7", x"FFE9", 
x"FFED", x"FFF2", x"FFF9", x"0000", x"0006", x"000C", x"0011", x"0013", x"0013", x"0011", 
x"000D", x"0009", x"0003", x"FFFE", x"FFF9", x"FFF5", x"FFF2", x"FFF1", x"FFF2", x"FFF4", 
x"FFF7", x"FFFB", x"FFFF", x"0003", x"0007", x"0009", x"000B", x"000B", x"000A", x"0008", 
x"0005", x"0002", x"FFFF", x"FFFD", x"FFFA", x"FFF9", x"FFF8", x"FFF8", x"FFF9", x"FFFB", 
x"FFFD", x"FFFF", x"0001", x"0003", x"0005", x"0006", x"0006", x"0006", x"0005", x"0003", 
x"0001", x"0000", x"FFFF", x"FFFD", x"FFFC", x"FFFC", x"FFFC", x"FFFC", x"FFFD", x"FFFE", 
x"FFFF", x"0000", x"0001", x"0002", x"0002", x"0003", x"0003", x"0002", x"0001", x"0001", 
x"0000", x"FFFF", x"FFFF", x"FFFF", x"FFFE", x"FFFE", x"FFFF", x"FFFF", x"FFFF", x"FFFF", 
x"0000", x"0000", x"0000", x"0001", x"0001", x"0001", x"0001", x"0000", x"0000", x"0000", 
x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"FFFF", x"0000", 
x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000", x"0000"
   )
   );
begin 

    
    
    shiftSamplesAndMul : process(clock,reset)
        
        variable accumulator1 : signed (ACCUMULATOR_Bit_NB-1 DOWNTO 0);
        variable accumulator2 : signed (ACCUMULATOR_Bit_NB-1 DOWNTO 0);
    begin        
        if (reset = '1') then
            samples <= (others =>(others => '0'));
            cnt <= (others => '0');
            cnt2 <= (others => '0');
            calculate <= (others => '0');
            calculatedelayed <= (others => '0');
            oldLRCK <= '0';
            selector <= (others => '0');
            wAddrCnt <= to_unsigned(initialWAddress,wAddrCnt'length);
            firstWrite <= '0';
            firstRead <= (others => '0');
            RAMfull <= '0';
            RAMfulldelayed <= '0';
            cntNooffset <= (others => '0');
        elsif rising_edge(clock) then  
            
            we <= '0';
            if en = '1' then
                
                firstWrite <= '1';
                initialRAddress <= ((wAddrCnt+(2*n)- initialWAddress));
           
                wAddrCnt <= wAddrCnt + n;
                we <= '1';
                din <= std_ulogic_vector(unsigned(audio_In(audio_In'length-1 downto (audio_In'length-(audio_In'length/2)))));
                wraddr <= std_ulogic_vector(wAddrCnt);
                
            end if;
           
            if firstWrite = '1' then 
                calculate <= to_unsigned(1,calculate'length);
                cntNooffset   <= (others => '0');   
                firstWrite <= '0';
                wAddrCnt <= wAddrCnt + n;
                
                rAddrCnt_Plus <= initialRAddress;
                rdaddr <= std_ulogic_vector(initialRAddress); 
                if wAddrCnt >= RAMLength then
                    RAMfull <= '1';
                
                    wAddrCnt <= to_unsigned(initialWAddress,wAddrCnt'length);
                end if;
                RAMfulldelayed <= RAMfull;
                we <= '1';
                din <= std_ulogic_vector(unsigned(audio_In((audio_In'length-(audio_In'length/2)-1) downto 0)));
                wraddr <= std_ulogic_vector(wAddrCnt);
            end if ; 
            
            calculatedelayed <= calculate;
            re <= '0';
           
         
            
            if calculatedelayed > 0  and RAMfull = '1' then 
                
                re <= '1';
                if cntNooffset < 5 then 
                    sample1 <= (others => '0');
                    cnt <= (others => '0');
                end if ;
                if cntNooffset >= RAMLength + 2 then 
                    calculate <= calculate-1;   
                    cntNooffset   <= (others => '0');   
                    lowPass <= resize(shift_right(accumulator1,ACCUMULATOR_Bit_NB-Lowpass'length-10),Lowpass'length);
                    Highpass <= resize(shift_right(accumulator2,ACCUMULATOR_Bit_NB-Lowpass'length-10),Lowpass'length);
                    cnt <= (others => '0');  
                    accumulator1 := (others => '0'); 
                    accumulator2 := (others => '0');  
                else
                    cntNooffset <= cntNooffset + 1; 
                end if;
                rdaddr <= std_ulogic_vector(rAddrCnt_Plus); 
                if (rAddrCnt_Plus mod 2) = 0 then 
                    rAddrCnt_Plus <= rAddrCnt_Plus + 1;
                    firstRead <= firstRead +1;
                    temp1(temp1'length-1 downto (temp1'length-(temp1'length/2))) <= signed(dout1);
                    sample1 <= temp1; 
                end if;
                if (rAddrCnt_Plus mod 2 = 1)  then 
                    rAddrCnt_Plus <= rAddrCnt_Plus + 1;
                    firstRead <= (others => '0');
                    temp1((temp1'length-(temp1'length/2)-1) downto 0)  <= signed(dout1);
                   
                end if;
              
              
                
                if rAddrCnt_Plus >= RAMLength then     
                    rAddrCnt_Plus  <= to_unsigned(initialWAddress,wAddrCnt'length);
                end if;
                
                if cntNooffset >= 5  and (cntNooffset mod 2) = 1 then 
                
                    cnt <= cnt+1;
                    accumulator1 := accumulator1 + sample1 * coeff(0,to_integer(cnt));
                    accumulator2 := accumulator2 + sample1 * coeff(1,to_integer(cnt));
                
                end if;
                
                

            
                   
            end if;
           
            
        end if ;
    end process shiftSamplesAndMul;
    
     DataReady <= '1' when calculate = 0 else '0';
     DebugData(1) <= '0'; 
     DebugData(0) <= '0'; 
     

    
     
END ARCHITECTURE FirstArchi;





-- VHDL Entity Splitter.iisEncoder.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 12:55:40 30.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;  
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY iisEncoder IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        reset      : IN     std_ulogic;
        clock      : IN     std_ulogic;
        audioLeft  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        LRCK       : OUT    std_ulogic;
        SCK        : OUT    std_ulogic;
        DOUT       : OUT    std_ulogic;
        CLKI2s     : IN     std_uLogic;
        LRCK1      : IN     std_uLogic;
        NewData    : OUT    std_uLogic;
        Frameout0  : OUT    std_uLogic
    );

-- Declarations

END iisEncoder ;





--
-- VHDL Architecture Splitter.iisEncoder.inputLRCK
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 08:46:24 02.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;  
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;
  
ARCHITECTURE inputLRCK OF iisEncoder IS

    signal lrckDelayed, lrckChanged : std_ulogic;
    signal sckDelayed, sckRising, sckFalling : std_ulogic;
    constant frameLength : positive := audioLeft'length;
    constant frameCounterBitNb : positive := requiredBitNb(frameLength-1);
  
   
    signal frameCounter : unsigned(frameCounterBitNb-1 downto 0);
    signal frameCounter2 : unsigned(frameCounterBitNb-1 downto 0);
    signal LRCKShifted :  std_uLogic;
    signal leftShiftRegister : signed(audioLeft'range);
    signal rightShiftRegister : signed(audioRight'range);
  

begin

    delaySck: process(reset, clock)
	begin
		if reset = '1' then
			sckDelayed <= '0';
            lrckDelayed <= '0';
		elsif rising_edge(clock) then
            sckDelayed <= CLKI2s;
            lrckDelayed <= LRCK1;
        end if;
    end process delaySck;
    
    sckRising <= '1' when (CLKI2s = '1') and (sckDelayed = '0')
        else '0';

    sckFalling <= '1' when (CLKI2s = '0') and (sckDelayed = '1')
        else '0';

    lrckChanged <= '1' when LRCK1 /= lrckDelayed
        else '0';

    FlipFlopAndResize: process(reset, clock)
	begin
		if reset = '1' then
			frameCounter <= (others => '0');
			frameCounter2 <= (others => '0');
            leftShiftRegister <= (others => '0');
            rightShiftRegister <= (others => '0');

            LRCKShifted <= '0';
           -- switch <= '0';
		elsif rising_edge(clock) then
		     
            NewData <= '0';

            if sckRising = '1' then            
                frameCounter <= frameCounter-1; 
                frameCounter2 <= frameCounter; 
                LRCKShifted  <= LRCK1;              
                          
            elsif sckFalling = '1' then
                if LRCKShifted = '0' then 
                    DOUT <= leftShiftRegister(to_integer(frameCounter2));
                else 
                    DOUT <= rightShiftRegister(to_integer(frameCounter2)) ; 
                end if;       
            end if;  
             
            if lrckChanged = '1' then  
                frameCounter <= (others => '1');
            end if ; 
            
            if frameCounter = 3 and LRCKShifted = '1' and CLKI2s = '0' then 
                NewData <= '1';
            end if ;
            if frameCounter = 3 and LRCKShifted = '1' and CLKI2s = '1' then 
                rightShiftRegister <= audioRight;
                leftShiftRegister <= audioLeft;
            end if ;    
        LRCK <= LRCK1;  
        SCK <= CLKI2s;
        Frameout0 <= frameCounter(0);
		end if;
	end process FlipFlopAndResize;
    
    
  -- DOUT <= leftShiftRegister(to_integer(frameCounter))when LRCK1 = '1' 
   --else rightShiftRegister(to_integer(frameCounter)) ;
    
    
END ARCHITECTURE inputLRCK;     



-- VHDL Entity Memory.bramDualport.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:49:31 14.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
    USE ieee.std_logic_1164.all;
    USE ieee.numeric_std.all;

ENTITY bramDualport IS
    GENERIC( 
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT( 
        clockA   : IN     std_ulogic;
        enA      : IN     std_ulogic;
        writeEnA : IN     std_ulogic;
        addressA : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInA  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutA : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        clockB   : IN     std_ulogic;
        enB      : IN     std_ulogic;
        writeEnB : IN     std_ulogic;
        addressB : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutB : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );

-- Declarations

END bramDualport ;





USE std.textio.all;

ARCHITECTURE bhv OF bramDualport IS
  -- Define ramContent type
  type ramContentType is array(0 to (2**addressBitNb)-1) of bit_vector(dataBitNb-1 DOWNTO 0);

  -- Declare ramContent signal
  shared variable ramContent: ramContentType;

BEGIN
  -- Port A
  process(clockA)
  begin
    if clockA'event and clockA='1' then
      if enA = '1' then
        if writeEnA = '1' then
          dataOutA <= dataInA;
          ramContent(to_integer(unsigned(addressA))) := to_bitvector(dataInA,'0');
        else
          dataOutA <= to_stdulogicvector(ramContent(to_integer(unsigned(addressA))));
        end if;
      end if;
    end if;
  end process;

  -- Port B
  process(clockB)
  begin
    if clockB'event and clockB='1' then
      if enB = '1' then
        if writeEnB = '1' then
          ramContent(to_integer(unsigned(addressB))) := to_bitvector(dataInB,'0');
          dataOutB <= dataInB;
        else
          dataOutB <= to_stdulogicvector(ramContent(to_integer(unsigned(addressB))));
        end if;
      end if;
    end if;
  end process;

END ARCHITECTURE bhv;




-- VHDL Entity Splitter.SeialSync.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 12:54:43 27.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY SeialSync IS
    GENERIC( 
        DATA_WIDTH : positive
    );
    PORT( 
        DataReady   : IN     std_ulogic;
        LR_I        : IN     std_uLogic;
        NewData     : IN     std_uLogic;
        clock       : IN     std_uLogic;
        highPass    : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass     : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        reset       : IN     std_uLogic;
        audioLeft1  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight1 : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );

-- Declarations

END SeialSync ;





--
-- VHDL Architecture Splitter.SeialSync.sync1
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 15:45:51 22.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
    ARCHITECTURE sync1 OF SeialSync IS

 signal oldR : std_ulogic;
 signal oldLR : std_ulogic;
 signal cnt : unsigned(2 downto 0); 
 signal tempLow : signed(lowPass'range);
 signal tempHigh : signed(highPass'range);

BEGIN



    syncro : process(clock,reset)
    begin
        if (reset = '1') then
           oldR <= '0'; 
           oldLR <= '0'; 
           cnt <= (others => '0');
           tempHigh <= (others => '0');
           tempLow <= (others => '0');
        elsif rising_edge(clock) then  
        
            if DataReady = '1' then 
                tempLow <= lowPass;
                tempHigh <= highPass ;
                tempLow(0) <= '0';
                tempLow(1) <= '0';
                tempLow(2) <= '0';
                tempHigh(0) <= '0';
                tempHigh(1) <= '0';
                tempHigh(2) <= '0';
            end if;
            
            --if NewData = '1' then 
                audioRight1 <= tempLow;
                -- to account for the higher efficency of the twitter
                audioLeft1 <= shift_right(tempHigh,1);       
            --end if;
            
            
            
        end if;
    end process syncro;

END ARCHITECTURE sync1;




-- VHDL Entity Splitter.risingEdgeDetector.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:00:47 02.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY risingEdgeDetector IS
    PORT( 
        clock     : IN     std_logic;
        dataValid : IN     std_logic;
        reset     : IN     std_logic;
        en        : OUT    std_logic
    );

-- Declarations

END risingEdgeDetector ;






ARCHITECTURE edge OF risingEdgeDetector IS

    signal signalDelayed : std_logic;

BEGIN

    delaySignal : process(clock,reset)
    begin 
    
        if reset = '1' then
			signalDelayed <= '0';
		elsif rising_edge(clock) then
           signalDelayed <= DataValid;
        end if;
    end process delaySignal;
    
    en <= '1' when (DataValid = '1') and (signalDelayed = '0')
        else '0';
END ARCHITECTURE edge;

 



-- VHDL Entity Splitter.muxOut.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:58:06 12.06.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY muxOut IS
    PORT( 
        CLK_I  : IN     std_uLogic;
        DOUT   : IN     std_ulogic;
        Data_I : IN     std_uLogic;
        LRCK   : IN     std_ulogic;
        LR_I   : IN     std_uLogic;
        S20    : IN     std_ulogic;
        SCK    : IN     std_ulogic;
        CLK_O  : OUT    std_uLogic;
        Data_O : OUT    std_uLogic;
        LR_O   : OUT    std_ulogic
    );

-- Declarations

END muxOut ;





--
-- VHDL Architecture Splitter.muxOut.TIOrFPGA
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 09:58:06 12.06.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE TIOrFPGA OF muxOut IS
BEGIN


    
    Data_O <= DOUT when S20 = '0' else Data_I ;
    LR_O <= LRCK when S20 = '0' else LR_I ;
    CLK_O <= SCK when S20 = '0' else CLK_I ;


END ARCHITECTURE TIOrFPGA;





-- VHDL Entity Splitter.delayer.symbol
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 14:20:38 03.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

ENTITY delayer IS
    PORT( 
        Data         : IN     std_ulogic;
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        Data_delayed : OUT    std_logic
    );

-- Declarations

END delayer ;





--
-- VHDL Architecture Splitter.delayer.delay1
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 14:20:38 03.07.2023
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE delay1 OF delayer IS
BEGIN
    delaySignal : process(clock,reset)
    begin 
    
        if reset = '1' then
			data_delayed <= '0';
		elsif rising_edge(clock) then
           data_delayed <= Data;
        end if;
    end process delaySignal;
    
END ARCHITECTURE delay1;





--
-- VHDL Architecture Splitter.leftRightSplitter.visitorsVersion
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 16:11:31 14.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

-- LIBRARY Memory;
-- LIBRARY Splitter;
-- LIBRARY Splitter_test;

ARCHITECTURE visitorsVersion OF leftRightSplitter IS

    -- Architecture declarations
    constant DATA_WIDTH : positive := 32;
    constant COEFF_BIT_NB : positive := 16;
    constant FILTER_TAP_NB : positive := 499;
    constant DATA_IN_WIDTH : positive := 32;
    constant addressBitNb :positive := 10;
    constant dataBitNb :positive := 16;
    constant initFile : string := "bramInit.txt";

    -- Internal signal declarations
    SIGNAL DOUT        : std_ulogic;
    SIGNAL Data        : std_ulogic;
    SIGNAL DataReady   : std_ulogic;
    SIGNAL DebugData   : unsigned(1 DOWNTO 0);
    SIGNAL Frameout0   : std_uLogic;
    SIGNAL LRCK        : std_ulogic;
    SIGNAL NewData     : std_uLogic;
    SIGNAL Next_data   : std_ulogic;
    SIGNAL SCK         : std_ulogic;
    SIGNAL audioLeft   : signed(DATA_IN_WIDTH-1 DOWNTO 0);
    SIGNAL audioLeft1  : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL audioRight  : signed(DATA_IN_WIDTH-1 DOWNTO 0);
    SIGNAL audioRight1 : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL audio_R_out : signed(DATA_WIDTH-1 DOWNTO 0);
    SIGNAL dataInB     : std_ulogic_vector(15 DOWNTO 0);
    SIGNAL dataValid   : std_ulogic;
    SIGNAL din         : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL dout1       : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL en          : std_logic;
    SIGNAL end_Calc    : std_ulogic;
    SIGNAL highPass    : signed(DATA_WIDTH-1  DOWNTO  0);
    SIGNAL lowPass     : signed(DATA_WIDTH-1  DOWNTO  0);
    SIGNAL rdaddr      : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL re          : std_ulogic;
    SIGNAL we          : std_ulogic;
    SIGNAL wraddr      : std_ulogic_vector(addressBitNb-1 DOWNTO 0);
    SIGNAL writeEnA    : std_ulogic;
    SIGNAL writeEnB    : std_ulogic;


    -- Component Declarations
    COMPONENT bramDualport
    GENERIC (
        addressBitNb : positive := 8;
        dataBitNb    : positive := 8;
        initFile     : string   := "bramInit.txt"
    );
    PORT (
        clockA   : IN     std_ulogic ;
        enA      : IN     std_ulogic ;
        writeEnA : IN     std_ulogic ;
        addressA : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInA  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutA : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        clockB   : IN     std_ulogic ;
        enB      : IN     std_ulogic ;
        writeEnB : IN     std_ulogic ;
        addressB : IN     std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        dataInB  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataOutB : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT HighLevel
    GENERIC (
        dataBitNb : positive
    );
    PORT (
        dataInB  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        writeEnA : OUT    std_ulogic ;
        writeEnB : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT SeialSync
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        DataReady   : IN     std_ulogic ;
        LR_I        : IN     std_uLogic ;
        NewData     : IN     std_uLogic ;
        clock       : IN     std_uLogic ;
        highPass    : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass     : IN     signed (DATA_WIDTH-1  DOWNTO  0);
        reset       : IN     std_uLogic ;
        audioLeft1  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight1 : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT Xover_with_RAM
    GENERIC (
        DATA_WIDTH    : positive;
        FILTER_TAP_NB : positive;
        COEFF_BIT_NB  : positive;
        dataBitNb     : positive;
        addressBitNb  : positive
    );
    PORT (
        audio_In  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock     : IN     std_ulogic ;
        dout1     : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        en        : IN     std_logic ;
        reset     : IN     std_ulogic ;
        DataReady : OUT    std_ulogic ;
        DebugData : OUT    unsigned (1 DOWNTO 0);
        din       : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        highPass  : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        lowPass   : OUT    signed (DATA_WIDTH-1  DOWNTO  0);
        rdaddr    : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0);
        re        : OUT    std_ulogic ;
        we        : OUT    std_ulogic ;
        wraddr    : OUT    std_ulogic_vector (addressBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT delayer
    PORT (
        Data         : IN     std_ulogic ;
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        Data_delayed : OUT    std_logic 
    );
    END COMPONENT;
    COMPONENT iisDecoder
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        reset      : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        LRCK       : IN     std_ulogic ;
        SCK        : IN     std_ulogic ;
        DOUT       : IN     std_ulogic ;
        dataValid  : OUT    std_ulogic ;
        audioLeft  : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        lr2        : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT iisEncoder
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        reset      : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        audioLeft  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audioRight : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        LRCK       : OUT    std_ulogic ;
        SCK        : OUT    std_ulogic ;
        DOUT       : OUT    std_ulogic ;
        CLKI2s     : IN     std_uLogic ;
        LRCK1      : IN     std_uLogic ;
        NewData    : OUT    std_uLogic ;
        Frameout0  : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT muxOut
    PORT (
        CLK_I  : IN     std_uLogic ;
        DOUT   : IN     std_ulogic ;
        Data_I : IN     std_uLogic ;
        LRCK   : IN     std_ulogic ;
        LR_I   : IN     std_uLogic ;
        S20    : IN     std_ulogic ;
        SCK    : IN     std_ulogic ;
        CLK_O  : OUT    std_uLogic ;
        Data_O : OUT    std_uLogic ;
        LR_O   : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT risingEdgeDetector
    PORT (
        clock     : IN     std_logic ;
        dataValid : IN     std_logic ;
        reset     : IN     std_logic ;
        en        : OUT    std_logic 
    );
    END COMPONENT;
    COMPONENT bascule
    GENERIC (
        DATA_WIDTH : positive
    );
    PORT (
        audio_L_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_in  : IN     signed (DATA_WIDTH-1 DOWNTO 0);
        clock       : IN     std_ulogic ;
        dataVAlid   : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        audio_L_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0);
        audio_R_out : OUT    signed (DATA_WIDTH-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : HighLevel USE ENTITY Splitter.HighLevel;
--     FOR ALL : SeialSync USE ENTITY Splitter.SeialSync;
--     FOR ALL : Xover_with_RAM USE ENTITY Splitter.Xover_with_RAM;
--     FOR ALL : bascule USE ENTITY Splitter_test.bascule;
--     FOR ALL : bramDualport USE ENTITY Memory.bramDualport;
--     FOR ALL : delayer USE ENTITY Splitter.delayer;
--     FOR ALL : iisDecoder USE ENTITY Splitter.iisDecoder;
--     FOR ALL : iisEncoder USE ENTITY Splitter.iisEncoder;
--     FOR ALL : muxOut USE ENTITY Splitter.muxOut;
--     FOR ALL : risingEdgeDetector USE ENTITY Splitter.risingEdgeDetector;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    testOut(0) <= DebugData(1);
    testOut(1) <= DebugData(0);
    testOut(2) <= audio_R_out(audio_R_out'high);
    testOut(3) <= audio_R_out(audio_R_out'high-1);
    testOut(4) <= audioRight1(audioRight'high-4);
    testOut(5) <= Frameout0;
    testOut(6) <= '0';


    -- Instance port mappings.
    I3 : bramDualport
        GENERIC MAP (
            addressBitNb => addressBitNb,
            dataBitNb    => dataBitNb,
            initFile     => initFile
        )
        PORT MAP (
            clockA   => clock,
            enA      => we,
            writeEnA => writeEnA,
            addressA => wraddr,
            dataInA  => din,
            dataOutA => OPEN,
            clockB   => clock,
            enB      => re,
            writeEnB => writeEnB,
            addressB => rdaddr,
            dataInB  => dataInB,
            dataOutB => dout1
        );
    I10 : HighLevel
        GENERIC MAP (
            dataBitNb => 16
        )
        PORT MAP (
            dataInB  => dataInB,
            writeEnA => writeEnA,
            writeEnB => writeEnB
        );
    I4 : SeialSync
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            DataReady   => end_Calc,
            LR_I        => LR_I,
            NewData     => Next_data,
            clock       => clock,
            highPass    => highPass,
            lowPass     => lowPass,
            reset       => reset,
            audioLeft1  => audioLeft1,
            audioRight1 => audioRight1
        );
    I11 : Xover_with_RAM
        GENERIC MAP (
            DATA_WIDTH    => DATA_WIDTH,
            FILTER_TAP_NB => FILTER_TAP_NB,
            COEFF_BIT_NB  => COEFF_BIT_NB,
            dataBitNb     => dataBitNb,
            addressBitNb  => addressBitNb
        )
        PORT MAP (
            audio_In  => audio_R_out,
            clock     => clock,
            dout1     => dout1,
            en        => en,
            reset     => reset,
            DataReady => DataReady,
            DebugData => DebugData,
            din       => din,
            highPass  => highPass,
            lowPass   => lowPass,
            rdaddr    => rdaddr,
            re        => re,
            we        => we,
            wraddr    => wraddr
        );
    I9 : delayer
        PORT MAP (
            Data         => Data,
            clock        => clock,
            reset        => reset,
            Data_delayed => en
        );
    I0 : iisDecoder
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            reset      => reset,
            clock      => clock,
            LRCK       => LR_I,
            SCK        => CLK_I,
            DOUT       => Data_I,
            dataValid  => dataValid,
            audioLeft  => audioLeft,
            audioRight => audioRight,
            lr2        => OPEN
        );
    I2 : iisEncoder
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            reset      => reset,
            clock      => clock,
            audioLeft  => audioLeft1,
            audioRight => audioRight1,
            LRCK       => LRCK,
            SCK        => SCK,
            DOUT       => DOUT,
            CLKI2s     => CLK_I,
            LRCK1      => LR_I,
            NewData    => NewData,
            Frameout0  => Frameout0
        );
    I8 : muxOut
        PORT MAP (
            CLK_I  => CLK_I,
            DOUT   => DOUT,
            Data_I => Data_I,
            LRCK   => LRCK,
            LR_I   => LR_I,
            S20    => S20,
            SCK    => SCK,
            CLK_O  => CLK_O,
            Data_O => Data_O,
            LR_O   => LR_O
        );
    I5 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => dataValid,
            reset     => reset,
            en        => Data
        );
    I6 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => DataReady,
            reset     => reset,
            en        => end_Calc
        );
    I7 : risingEdgeDetector
        PORT MAP (
            clock     => clock,
            dataValid => NewData,
            reset     => reset,
            en        => Next_data
        );
    I1 : bascule
        GENERIC MAP (
            DATA_WIDTH => DATA_WIDTH
        )
        PORT MAP (
            audio_L_in  => audioRight,
            audio_R_in  => audioLeft,
            clock       => clock,
            dataVAlid   => Data,
            reset       => reset,
            audio_L_out => OPEN,
            audio_R_out => audio_R_out
        );

END visitorsVersion;




-- VHDL Entity gates.inverter.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY inverter IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverter ;





ARCHITECTURE sim OF inverter IS
BEGIN
  out1 <= NOT in1 after delay;
END sim;




-- VHDL Entity gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




-- VHDL Entity sequential.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY DFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0' after delay;
    elsif rising_edge(clk) then
      q <= d after delay;
    end if;
  end process;

END sim;




--
-- VHDL Architecture Board.FPGA_splitter.struct
--
-- Created:
--          by - maxime.cesalli.UNKNOWN (WE2330804)
--          at - 10:32:58 14.07.2023
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

-- LIBRARY sequential;
-- LIBRARY Splitter;

ARCHITECTURE struct OF FPGA_splitter IS

    -- Architecture declarations
    constant clockFrequency: real := 66.0E6;
    constant rs232BaudRate: real := 115.2E3;
    constant pwmFrequency: real := 100.0E3;
    constant mainsFrequency: real := 50.0;
    constant debounceCounterBitNb: positive := requiredBitNb(integer(clockFrequency/100.0));
    constant spikeFilterCounterBitNb: positive := requiredBitNb(10);
    constant buttonsRepeatFrequency: real := 100.0;
    constant controlAmplitudeBitNb: natural := 10;
    constant proportionalShift: integer := -14;
    constant integratorShift: integer := -12;
    constant testLineNb: positive := 16;

    -- Internal signal declarations
    SIGNAL CLK_I        : std_uLogic;
    SIGNAL CLK_O1       : std_uLogic;
    SIGNAL Data_I       : std_uLogic;
    SIGNAL Data_O1      : std_uLogic;
    SIGNAL LR_I         : std_uLogic;
    SIGNAL LR_O1        : std_ulogic;
    SIGNAL reset        : std_ulogic;
    SIGNAL reset1       : std_ulogic;
    SIGNAL resetSynch   : std_ulogic;
    SIGNAL resetSynch_n : std_ulogic;


    -- Component Declarations
    COMPONENT inverter
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT DFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT leftRightSplitter
    GENERIC (
        signalBitNb  : positive := 24;
        signalOBitNb : positive := 32
    );
    PORT (
        CLK_I   : IN     std_uLogic ;
        Data_I  : IN     std_uLogic ;
        LR_I    : IN     std_uLogic ;
        S20     : IN     std_ulogic ;
        S21     : IN     std_ulogic ;
        S22     : IN     std_ulogic ;
        S23     : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        CLK_O   : OUT    std_uLogic ;
        Data_O  : OUT    std_uLogic ;
        LR_O    : OUT    std_ulogic ;
        testOut : OUT    std_ulogic_vector (6 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF USE ENTITY sequential.DFF;
--     FOR ALL : inverter USE ENTITY gates.inverter;
--     FOR ALL : leftRightSplitter USE ENTITY Splitter.leftRightSplitter;
--     FOR ALL : logic1 USE ENTITY gates.logic1;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    I1 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => reset_n,
            out1 => reset
        );
    I7 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => resetSynch_n,
            out1 => resetSynch
        );
    I28 : logic1
        PORT MAP (
            logic_1 => reset1
        );
    I_rst : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => reset1,
            Q   => resetSynch_n
        );
    I_rst1 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => LR_In,
            Q   => LR_I
        );
    I_rst2 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => Data_In,
            Q   => Data_I
        );
    I_rst3 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => CLK_In,
            Q   => CLK_I
        );
    I_rst4 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => Data_O1,
            Q   => Data_O
        );
    I_rst5 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => CLK_O1,
            Q   => CLK_O
        );
    I_rst6 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => LR_O1,
            Q   => LR_O
        );
    I0 : leftRightSplitter
        GENERIC MAP (
            signalBitNb  => 24,
            signalOBitNb => 32
        )
        PORT MAP (
            CLK_I   => CLK_I,
            Data_I  => Data_I,
            LR_I    => LR_I,
            S20     => S20,
            S21     => S21,
            S22     => S22,
            S23     => S23,
            clock   => clock,
            reset   => resetSynch,
            CLK_O   => CLK_O1,
            Data_O  => Data_O1,
            LR_O    => LR_O1,
            testOut => testOut
        );

END struct;




