-- VHDL Entity Board.FPGA_generatorControl.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 16:00:49 10/13/20
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FPGA_generatorControl IS
    GENERIC( 
        buttonNb : positive := 4;
        ledNb    : positive := 8
    );
    PORT( 
        RxD       : IN     std_ulogic;
        buttons_n : IN     std_uLogic_vector (1 TO buttonNb);
        clock     : IN     std_ulogic;
        generator : IN     std_uLogic;
        mains     : IN     std_uLogic;
        reset_n   : IN     std_ulogic;
        LED1      : OUT    std_uLogic;
        LED2      : OUT    std_ulogic;
        LEDs_n    : OUT    std_ulogic_vector (1 TO ledNb);
        TxD       : OUT    std_ulogic;
        pwm       : OUT    std_uLogic;
        test      : OUT    std_uLogic_vector (1 TO 10)
    );

-- Declarations

END FPGA_generatorControl ;





LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity gates.inverter.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY inverter IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverter ;





ARCHITECTURE sim OF inverter IS
BEGIN
  out1 <= NOT in1 after delay;
END sim;




-- VHDL Entity gates.bufferUlogic.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:48 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY bufferUlogic IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END bufferUlogic ;





ARCHITECTURE sim OF bufferUlogic IS
BEGIN
  out1 <= in1 after delay;
END ARCHITECTURE sim;




-- VHDL Entity gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




-- VHDL Entity GeneratorControl.generatorControl.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:29 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

ENTITY generatorControl IS
    GENERIC( 
        clockFrequency         : real     := 66.0E6;
        rs232BaudRate          : real     := 115.2E3;
        pwmFrequency           : real     := 100.0E3;
        mainsFrequency         : real     := 50.0;
        buttonsRepeatFrequency : real     := 0.5;
        controlAmplitudeBitNb  : positive := 10;
        proportionalShift      : integer  := 8;
        integratorShift        : integer  := 1;
        buttonNb               : positive := 4;
        ledNb                  : positive := 7;
        testLineNb             : positive := 8
    );
    PORT( 
        RxD       : IN     std_ulogic;
        buttons   : IN     std_uLogic_vector (1 TO buttonNb);
        clock     : IN     std_ulogic;
        generator : IN     std_uLogic;
        mains     : IN     std_uLogic;
        reset     : IN     std_ulogic;
        TxD       : OUT    std_ulogic;
        leds      : OUT    std_uLogic_vector (1 TO ledNb);
        pwm       : OUT    std_uLogic;
        testOut   : OUT    std_uLogic_vector (1 TO testLineNb)
    );

-- Declarations

END generatorControl ;





-- VHDL Entity GeneratorControl.buttonRepeatCounter.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 13:03:31 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY buttonRepeatCounter IS
    GENERIC( 
        clockFrequency  : real := 100.0E6;
        repeatFrequency : real := 0.5
    );
    PORT( 
        clock          : IN     std_ulogic;
        reset          : IN     std_ulogic;
        restartCounter : IN     std_ulogic;
        counterDone    : OUT    std_ulogic
    );

-- Declarations

END buttonRepeatCounter ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




-- LIBRARY Common;
  use work.CommonLib.all;

ARCHITECTURE RTL OF buttonRepeatCounter IS

  constant counterBitNb : positive := requiredBitNb(integer(
    clockFrequency / repeatFrequency
  ));
  signal repeatCounter: unsigned(counterBitNb-1 downto 0);

BEGIN

  countRepeatPeriod: process(reset, clock)
  begin
    if reset = '1' then
      repeatCounter <= (others => '0');
    elsif rising_edge(clock) then
      if restartCounter = '1' then
        repeatCounter <= to_unsigned(1, repeatCounter'length);
      elsif repeatCounter > 0 then
        repeatCounter <= repeatCounter + 1;
      end if;
    end if;
  end process countRepeatPeriod;

  counterDone <= '1' when repeatCounter+1 = 0
    else '0';

END ARCHITECTURE RTL;




-- VHDL Entity GeneratorControl.buttonControl.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:47 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY buttonControl IS
    PORT( 
        clock          : IN     std_ulogic;
        counterDone    : IN     std_ulogic;
        decrease       : IN     std_ulogic;
        increase       : IN     std_ulogic;
        reset          : IN     std_ulogic;
        selectToggle   : IN     std_ulogic;
        decrement      : OUT    std_ulogic;
        increment      : OUT    std_ulogic;
        restartCounter : OUT    std_ulogic;
        selectManual   : OUT    std_ulogic;
        selectRegType  : OUT    unsigned (1 DOWNTO 0)
    );

-- Declarations

END buttonControl ;





--
-- VHDL Architecture GeneratorControl.buttonControl.fsm
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:48 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF buttonControl IS

    TYPE STATE_TYPE IS (
        PIMode,
        toManualMode,
        manualMode,
        incPressed,
        incWaitForRelease,
        decPressed,
        incWaitForRelease1,
        toIMode,
        IMode,
        toUartMode,
        uartMode,
        toPIMode
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clock,
        reset
    )
    -----------------------------------------------------------------
    BEGIN
        IF (reset = '1') THEN
            current_state <= PIMode;
        ELSIF (clock'EVENT AND clock = '1') THEN
            current_state <= next_state;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        counterDone,
        current_state,
        decrease,
        increase,
        selectToggle
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN PIMode => 
                IF (selectToggle = '1') THEN 
                    next_state <= toManualMode;
                ELSE
                    next_state <= PIMode;
                END IF;
            WHEN toManualMode => 
                IF (selectToggle = '0') THEN 
                    next_state <= manualMode;
                ELSE
                    next_state <= toManualMode;
                END IF;
            WHEN manualMode => 
                IF (increase = '1') THEN 
                    next_state <= incPressed;
                ELSIF (decrease = '1') THEN 
                    next_state <= decPressed;
                ELSIF (selectToggle = '1') THEN 
                    next_state <= toIMode;
                ELSE
                    next_state <= manualMode;
                END IF;
            WHEN incPressed => 
                next_state <= incWaitForRelease;
            WHEN incWaitForRelease => 
                IF ((increase = '0') or (counterDone = '1')) THEN 
                    next_state <= manualMode;
                ELSE
                    next_state <= incWaitForRelease;
                END IF;
            WHEN decPressed => 
                next_state <= incWaitForRelease1;
            WHEN incWaitForRelease1 => 
                IF ((decrease = '0') or (counterDone = '1')) THEN 
                    next_state <= manualMode;
                ELSE
                    next_state <= incWaitForRelease1;
                END IF;
            WHEN toIMode => 
                IF (selectToggle = '0') THEN 
                    next_state <= IMode;
                ELSE
                    next_state <= toIMode;
                END IF;
            WHEN IMode => 
                IF (selectToggle = '1') THEN 
                    next_state <= toUartMode;
                ELSE
                    next_state <= IMode;
                END IF;
            WHEN toUartMode => 
                IF (selectToggle = '0') THEN 
                    next_state <= uartMode;
                ELSE
                    next_state <= toUartMode;
                END IF;
            WHEN uartMode => 
                IF (selectToggle = '1') THEN 
                    next_state <= toPIMode;
                ELSE
                    next_state <= uartMode;
                END IF;
            WHEN toPIMode => 
                IF (selectToggle = '0') THEN 
                    next_state <= PIMode;
                ELSE
                    next_state <= toPIMode;
                END IF;
            WHEN OTHERS =>
                next_state <= PIMode;
        END CASE;
    END PROCESS nextstate_proc;
 
    -----------------------------------------------------------------
    output_proc : PROCESS ( 
        current_state
    )
    -----------------------------------------------------------------
    BEGIN
        -- Default Assignment
        decrement <= '0';
        increment <= '0';
        restartCounter <= '0';
        selectManual <= '0';
        selectRegType <= (others => '0');

        -- Combined Actions
        CASE current_state IS
            WHEN PIMode => 
                selectRegType <= "00";
            WHEN toManualMode => 
                selectRegType <= "01";
                selectManual <= '1';
            WHEN manualMode => 
                selectRegType <= "01";
                selectManual <= '1';
            WHEN incPressed => 
                selectRegType <= "01";
                selectManual <= '1';
                increment <= '1';
                restartCounter <= '1';
            WHEN incWaitForRelease => 
                selectRegType <= "01";
                selectManual <= '1';
            WHEN decPressed => 
                selectRegType <= "01";
                selectManual <= '1';
                decrement <= '1';
                restartCounter <= '1';
            WHEN incWaitForRelease1 => 
                selectRegType <= "01";
                selectManual <= '1';
            WHEN toIMode => 
                selectRegType <= "10";
            WHEN IMode => 
                selectRegType <= "10";
            WHEN toUartMode => 
                selectRegType <= "11";
            WHEN uartMode => 
                selectRegType <= "11";
            WHEN toPIMode => 
                selectRegType <= "00";
            WHEN OTHERS =>
                NULL;
        END CASE;
    END PROCESS output_proc;
 
END fsm;




-- VHDL Entity GeneratorControl.frequencyRegulators.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:29 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY frequencyRegulators IS
    GENERIC( 
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        proportionalShift     : integer  := 0;
        integralShift         : integer  := 0;
        baudRateDivide        : positive := 2083
    );
    PORT( 
        clock            : IN     std_ulogic;
        en               : IN     std_ulogic;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        regulationType   : IN     unsigned (1 DOWNTO 0);
        reset            : IN     std_ulogic;
        rxD              : IN     std_ulogic;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        txD              : OUT    std_ulogic
    );

-- Declarations

END frequencyRegulators ;





-- VHDL Entity GeneratorControl.frequencyRegulatorI.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 13:00:48 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY frequencyRegulatorI IS
    GENERIC( 
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8
    );
    PORT( 
        clock            : IN     std_ulogic;
        en               : IN     std_ulogic;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic;
        sel              : IN     std_ulogic;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );

-- Declarations

END frequencyRegulatorI ;





-- LIBRARY Common;
  use work.CommonLib.all;

ARCHITECTURE masterVersion OF frequencyRegulatorI IS

  constant defaultAmplitude: unsigned(controlAmplitude'range)
    := shift_left(
      resize("01", controlAmplitude'length),
      controlAmplitude'length-1
    );
  signal accumulator: unsigned(controlAmplitude'range);

BEGIN
  ------------------------------------------------------------------------------
                                                                   -- integrator
  integrateAndZeroError: process(reset, clock)
  begin
    if reset = '1' then
      accumulator <= defaultAmplitude;
    elsif rising_edge(clock) then
      if sel = '1' then
        if en = '1' then
          if periodDiff < 0 then
            accumulator <= accumulator - 1;
          elsif periodDiff > 0 then
            accumulator <= accumulator + 1;
          end if;
        end if;
      else
--        accumulator <= defaultAmplitude - shift_right(defaultAmplitude, 2);
        accumulator <= defaultAmplitude;
      end if;
    end if;
  end process integrateAndZeroError;

  controlAmplitude <= accumulator;

END ARCHITECTURE masterVersion;




-- VHDL Entity GeneratorControl.frequencyRegulatorPI.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 12:59:47 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY frequencyRegulatorPI IS
    GENERIC( 
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        proportionalShift     : integer  := 0;
        integralShift         : integer  := 0
    );
    PORT( 
        clock            : IN     std_ulogic;
        en               : IN     std_ulogic;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );

-- Declarations

END frequencyRegulatorPI ;





ARCHITECTURE RTL OF frequencyRegulatorPI IS

  constant signedBitNb: positive := controlAmplitude'length + 1;
  constant outputOffset: signed(signedBitNb-1 downto 0)
    := shift_left(resize("01", signedBitNb), controlAmplitude'length-1);

  signal proportionalTerm            : signed(signedBitNb-1 downto 0);
  signal integralDelta, integralTerm : signed(signedBitNb-1 downto 0);
  signal sum                         : signed(signedBitNb-1 downto 0);

BEGIN
  ------------------------------------------------------------------------------
                                                            -- proportional term
  proportionalShiftLeft: if proportionalShift >= 0 generate
    proportionalTerm <= resize(
      shift_left(periodDiff, proportionalShift),
      proportionalTerm'length
    );
  end generate proportionalShiftLeft;

  proportionalShiftRight: if proportionalShift < 0 generate
    proportionalTerm <= resize(
      shift_right(periodDiff, -proportionalShift),
      proportionalTerm'length
    );
  end generate proportionalShiftRight;

  ------------------------------------------------------------------------------
                                                                -- integral term
  integralShiftLeft: if integralShift >= 0 generate
    integralDelta <= resize(
      shift_left(periodDiff, integralShift),
      integralDelta'length
    );
  end generate integralShiftLeft;

  integralShiftRight: if integralShift < 0 generate
    integralDelta <= resize(
      shift_right(periodDiff, -integralShift),
      integralDelta'length
    );
  end generate integralShiftRight;

  accumulate: process(reset, clock)
  begin
    if reset = '1' then
      integralTerm <= outputOffset;
    elsif rising_edge(clock) then
      if en = '1' then
        integralTerm <= integralTerm + integralDelta;
      end if;
    end if;
  end process;

  ------------------------------------------------------------------------------
                                                             -- regulator output
  addTerms: process(proportionalTerm, integralTerm)
    variable sum_v: signed(sum'range);
  begin
    sum_v := proportionalTerm + integralTerm;
    if sum_v < 0 then
      sum <= (others => '0');
    else
      sum <= sum_v;
    end if;
  end process addTerms;

  controlAmplitude <= resize(unsigned(sum), controlAmplitude'length);

END ARCHITECTURE RTL;




-- VHDL Entity GeneratorControl.frequencyRegulatorUart.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:29 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY frequencyRegulatorUart IS
    GENERIC( 
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        baudRateDivide        : positive := 2083
    );
    PORT( 
        clock            : IN     std_ulogic;
        en               : IN     std_ulogic;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic;
        rxD              : IN     std_ulogic;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        txD              : OUT    std_ulogic
    );

-- Declarations

END frequencyRegulatorUart ;





-- VHDL Entity GeneratorControl.serDes.symbol
--
-- Created:
--          by - francois.corthay.UNKNOWN (WE2330806)
--          at - 11:46:49 26.10.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serDes IS
    GENERIC( 
        parallelInBitNb  : positive := 8;
        parallelOutBitNb : positive := 8;
        serialPortBitNb  : integer  := 0
    );
    PORT( 
        clock       : IN     std_ulogic;
        parallelIn  : IN     signed (parallelInBitNb-1 DOWNTO 0);
        reset       : IN     std_ulogic;
        rxData      : IN     std_ulogic_vector (serialPortBitNb-1 DOWNTO 0);
        rxEmpty     : IN     std_ulogic;
        send        : IN     std_ulogic;
        txFull      : IN     std_ulogic;
        parallelOut : OUT    unsigned (parallelOutBitNb-1 DOWNTO 0);
        rxRd        : OUT    std_ulogic;
        txData      : OUT    std_ulogic_vector (serialPortBitNb-1 DOWNTO 0);
        txWr        : OUT    std_ulogic
    );

-- Declarations

END serDes ;





-- LIBRARY Common;
  use work.CommonLib.all;
-- LIBRARY RS232;

ARCHITECTURE RTL OF serDes IS

  constant defaultOut: unsigned(parallelOut'range)
    := shift_left(resize("01", parallelOut'length), parallelOut'length-1);
                                                                  -- serial port
  constant baudRateDivide : positive := 66E6/115200 / 10;
  constant uartBitNb : positive := 8;
  constant uartFifoDepth : positive := 1;
  signal txData_unsigned : unsigned(uartBitNb-1 downto 0);
  constant nibbleBitNb : positive := 4;
  constant sendNibbleCount : positive := ((parallelIn'length-1)/nibbleBitNb)+1;
  constant sendCounterBitNb : positive := requiredBitNb(sendNibbleCount+2);
  signal sendCounter : unsigned(sendCounterBitNb-1 downto 0);
  signal txWr_int, rxRd_int : std_ulogic;
  signal sendShiftRegister : unsigned(sendNibbleCount*nibbleBitNb-1 downto 0);
  signal sendNibble : unsigned(nibbleBitNb-1 downto 0);
  constant receiveNibbleCount : positive := ((parallelOut'length-1)/nibbleBitNb)+1;
  signal receiveShiftRegister : unsigned(receiveNibbleCount*nibbleBitNb-1 downto 0);
  signal lastReceivedWasControl : std_ulogic;

BEGIN
  ------------------------------------------------------------------------------
                                                    -- counter for sending value
  countSentNibbleSequence: process(reset, clock)
  begin
    if reset = '1' then
      sendCounter <= (others => '0');
    elsif rising_edge(clock) then
      if sendCounter = 0 then
        if send = '1' then
          sendCounter <= sendCounter + 1;
        end if;
      elsif txFull = '0' then
        sendCounter <= sendCounter + 1;
      end if;
    end if;
  end process countSentNibbleSequence;

  txWr_int <= '1' when (sendCounter > 0) and (sendCounter <= sendNibbleCount+2) and (txFull = '0')
    else '0';
  txWr <= txWr_int;
                                                          -- send shift register
  shiftSentNibbles: process(reset, clock)
  begin
    if reset = '1' then
      sendShiftRegister <= (others => '0');
    elsif rising_edge(clock) then
      if (send = '1') and (sendCounter = 0) then
        sendShiftRegister <= unsigned(resize(parallelIn, sendShiftRegister'length));
      elsif txWr_int = '1' then
        sendShiftRegister <= shift_left(sendShiftRegister, nibbleBitNb);
      end if;
    end if;
  end process shiftSentNibbles;

  sendNibble <= resize(
    shift_right(sendShiftRegister, sendShiftRegister'length-nibbleBitNb),
    sendNibble'length
  );

  selectSentData: process(sendCounter, sendNibble)
  begin
    if sendCounter <= sendNibbleCount then
      if sendNibble < 10 then
        txData_unsigned <= X"3" & sendNibble;
      else
        txData_unsigned <= X"4" & (sendNibble-10+1);
      end if;
    elsif sendCounter = sendNibbleCount+1 then
      txData_unsigned <= to_unsigned(character'pos(cr), txData_unsigned'length);
    elsif sendCounter = sendNibbleCount+2 then
      txData_unsigned <= to_unsigned(character'pos(lf), txData_unsigned'length);
    else
      txData_unsigned <= (others => '-');
    end if;
  end process selectSentData;

  txData <= std_ulogic_vector(txData_unsigned);

  ------------------------------------------------------------------------------
  rxRd_int <= not rxEmpty;
  rxRd <= rxRd_int;
                                                       -- receive shift register
  shiftReceivedNibbles: process(reset, clock)
    variable highNibble, lowNibble : unsigned(nibbleBitNb-1 downto 0);
  begin
    if reset = '1' then
      receiveShiftRegister <= (others => '0');
      lastReceivedWasControl <= '0';
      parallelOut <= defaultOut;
    elsif rising_edge(clock) then
      if rxRd_int = '1' then
        highNibble := resize(
          shift_right(unsigned(rxData), nibbleBitNb),
          highNibble'length
        );
        lowNibble := resize( unsigned(rxData), highNibble'length);
        if highNibble = 3 then
          receiveShiftRegister <= shift_left(receiveShiftRegister, lowNibble'length);
          receiveShiftRegister(lowNibble'range) <= lowNibble;
          lastReceivedWasControl <= '0';
        elsif (highNibble = 4) or (highNibble = 6) then
          receiveShiftRegister <= shift_left(receiveShiftRegister, lowNibble'length);
          receiveShiftRegister(lowNibble'range) <= lowNibble + 9;
          lastReceivedWasControl <= '0';
        elsif highNibble = 0 then
          if lastReceivedWasControl = '0' then
            parallelOut <= resize(
              receiveShiftRegister, parallelOut'length
            );
          end if;
          lastReceivedWasControl <= '1';
          receiveShiftRegister <= (others => '0');
        end if;
      end if;
    end if;
  end process shiftReceivedNibbles;

END ARCHITECTURE RTL;




-- VHDL Entity RS232.serialPortFIFO.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:49 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortFIFO IS
    GENERIC( 
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        txFifoDepth    : positive := 8;
        rxFifoDepth    : positive := 8
    );
    PORT( 
        RxD     : IN     std_ulogic;
        TxD     : OUT    std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        rxEmpty : OUT    std_ulogic;
        rxRd    : IN     std_ulogic;
        rxData  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txFull  : OUT    std_ulogic;
        txWr    : IN     std_ulogic
    );

-- Declarations

END serialPortFIFO ;





-- VHDL Entity RS232.serialPortReceiver.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:48 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortReceiver IS
    GENERIC( 
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT( 
        RxD       : IN     std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic
    );

-- Declarations

END serialPortReceiver ;





-- library Common;
  use work.CommonLib.all;

architecture RTL of serialPortReceiver is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide-1)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal rxDelayed: std_uLogic;
  signal dividerCounterSynchronize: std_uLogic;
  signal rxSample: std_uLogic;
  signal rxShiftReg: std_ulogic_vector(dataBitNb-1 downto 0);
  signal rxReceiving: std_uLogic;
  signal rxDataValid: std_uLogic;
  signal rxCounter: unsigned(requiredBitNb(dataBitNb)-1 downto 0);

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterSynchronize = '1' then
        dividerCounter <= to_unsigned(baudRateDivide/2, dividerCounter'length);
      elsif dividerCounterReset = '1' then
        dividerCounter <= (others => '0');
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter)
  begin
    if dividerCounter = baudRateDivide-1 then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  delayRx: process(reset, clock)
  begin
    if reset = '1' then
      rxDelayed <= '0';
    elsif rising_edge(clock) then
      rxDelayed <= RxD;
    end if;
  end process delayRx;

  rxSynchronize: process(RxD, rxDelayed)
  begin
    if RxD /= rxDelayed then
      dividerCounterSynchronize <= '1';
    else
      dividerCounterSynchronize <= '0';
    end if;
  end process rxSynchronize;

  rxSample <= dividerCounterReset;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        rxShiftReg(rxShiftReg'high-1 downto 0) <= rxShiftReg(rxShiftReg'high downto 1);
        rxShiftReg(rxShiftReg'high) <= RxD;
      end if;
    end if;
  end process shiftReg;

  detectReceive: process(reset, clock)
  begin
    if reset = '1' then
      rxReceiving <= '0';
      rxDataValid <= '0';
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxCounter = dataBitNb-1 then
          rxDataValid <= '1';
        elsif RxD = '0' then
          rxReceiving <= '1';
        end if;
      elsif rxDataValid = '1' then
        rxReceiving <= '0';
        rxDataValid <= '0';
      end if;
    end if;
  end process detectReceive;

  countRxBitNb: process(reset, clock)
  begin
    if reset = '1' then
      rxCounter <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxReceiving = '1' then
          rxCounter <= rxCounter + 1;
        else
          rxCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countRxBitNb;

  dataOut <= rxShiftReg;
  dataValid <= rxDataValid;

end RTL;





-- VHDL Entity Memory.FIFO.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 10:55:04 10/18/21
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO IS
    GENERIC( 
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO ;





-- VHDL Entity Memory.FIFO_oneRegister.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_oneRegister IS
    GENERIC( 
        dataBitNb : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO_oneRegister ;





architecture oneRegister of FIFO_oneRegister is

  signal dataRegister: std_ulogic_vector(dataIn'range);

begin

  writeReg: process(reset, clock)
  begin
    if reset = '1' then
      dataRegister <= (others => '0');
    elsif rising_edge(clock) then
      if write = '1' then
        dataRegister <= dataIn;
      end if;
    end if;
  end process writeReg;

  dataOut <= dataRegister;

  manageFlags: process(reset, clock)
  begin
    if reset = '1' then
      empty <= '1';
      full  <= '0';
    elsif rising_edge(clock) then
      if write = '1' then
        empty <= '0';
        full  <= '1';
      elsif read = '1' then
        empty <= '1';
        full  <= '0';
      end if;
    end if;
  end process manageFlags;

end oneRegister;





-- VHDL Entity Memory.FIFO_bram.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_bram IS
    GENERIC( 
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO_bram ;





-- library Common;
  use work.CommonLib.all;

architecture RTL of FIFO_bram is

  subtype register_type is std_ulogic_vector(dataIn'high downto 0);
  type memory_type is array (0 to depth-1) of register_type;

  signal writeCounter: unsigned(requiredBitNb(depth-1)-1 downto 0);
  signal readCounter: unsigned(writeCounter'range);
  signal memoryArray: memory_type;

  type fifoStateType is (
    sEmpty, sFull,
    sRead, sWrite, sWriteFirst,
    sReadWrite, sWait
  );
  signal fifoState: fifoStateType;
  signal emptyCondition, fullCondition, empty_int: std_ulogic;

begin
  ------------------------------------------------------------------------------
                                                      -- read and write counters
  updateWriteCounter: process(reset, clock)
  begin
    if reset = '1' then
      writeCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (write = '1') and  (fullCondition = '0') then
        writeCounter <= writeCounter + 1;
      end if;
    end if;
  end process updateWriteCounter;

  updateReadCounter: process(reset, clock)
  begin
    if reset = '1' then
      readCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '1') and  (empty_int = '0') then
        readCounter <= readCounter + 1;
      end if;
    end if;
  end process updateReadCounter;

  ------------------------------------------------------------------------------
                                                                -- memory access
  writeMem: process(clock)
  begin
    if rising_edge(clock) then
      if (write = '1') and (fullCondition = '0') then
        memoryArray(to_integer(writeCounter)) <= dataIn;
      end if;
    end if;
  end process writeMem;

  readMem: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '0') or (empty_int = '1') then
        dataOut <= memoryArray(to_integer(readCounter));
      else
        dataOut <= memoryArray(to_integer(readCounter+1));
      end if;
    end if;
  end process readMem;

  ------------------------------------------------------------------------------
                                                                     -- controls
  emptyCondition <= '1' when
      ( (fifoState = sRead) and (writeCounter = readCounter) ) or
        (fifoState = sEmpty)
    else '0';

  fullCondition <= '1' when
      ( (fifoState = sWrite) and (writeCounter = readCounter) ) or
        (fifoState = sFull)
    else '0';


  fifoControl: process(reset, clock)
  begin
    if reset = '1' then
      fifoState <= sEmpty;
    elsif rising_edge(clock) then
      case fifoState is
        when sEmpty =>
          if write = '1' then
            fifoState <= sWriteFirst;
          end if;
        when sFull =>
          if (read = '1') then
            fifoState <= sRead;
          end if;
        when sRead =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
		      elsif emptyCondition = '1' then
            fifoState <= sEmpty;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWriteFirst =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWrite =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
		      elsif fullCondition = '1' then
            fifoState <= sFull;
          elsif write = '1' then
            fifoState <= sWrite;
          else
            fifoState <= sWait;
          end if;
        when sReadWrite =>
          if (read = '0') and (write = '0') then
            fifoState <= sWait;
          elsif (read = '1') and (write = '0') then
            fifoState <= sRead;
          elsif (write = '1') and (read = '0') then
            fifoState <= sWrite;
          end if;
        when sWait =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
          elsif write = '1' then
            fifoState <= sWrite;
          end if;
        when others => null;
      end case;
    end if;
  end process fifoControl;
  

  full <= '1' when 
        (fifoState = sFull) or
        (fullCondition = '1')
    else '0';

  empty_int <= '1' when
        (fifoState = sEmpty) or
        (fifoState = sWriteFirst) or
        ( (emptyCondition = '1') and (fifoState = sRead) )
    else '0';
  empty <= empty_int;
  
end RTL;




--
-- VHDL Architecture Memory.FIFO.struct
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 10:55:04 10/18/21
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY Memory;

ARCHITECTURE struct OF FIFO IS

    -- Architecture declarations

    -- Internal signal declarations


    -- Component Declarations
    COMPONENT FIFO_bram
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT FIFO_oneRegister
    GENERIC (
        dataBitNb : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;


BEGIN

    -- Instance port mappings.

    g0: IF depth <= 1 GENERATE
    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : FIFO_oneRegister USE ENTITY Memory.FIFO_oneRegister;
    -- pragma synthesis_on

    BEGIN
        I1 : FIFO_oneRegister
            GENERIC MAP (
                dataBitNb => dataBitNb
            )
            PORT MAP (
                write   => write,
                clock   => clock,
                reset   => reset,
                dataOut => dataOut,
                read    => read,
                dataIn  => dataIn,
                empty   => empty,
                full    => full
            );
    END GENERATE g0;

    g1: IF depth > 1 GENERATE
    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : FIFO_bram USE ENTITY Memory.FIFO_bram;
    -- pragma synthesis_on

    BEGIN
        I0 : FIFO_bram
            GENERIC MAP (
                dataBitNb => dataBitNb,
                depth     => depth
            )
            PORT MAP (
                write   => write,
                clock   => clock,
                reset   => reset,
                dataOut => dataOut,
                read    => read,
                dataIn  => dataIn,
                empty   => empty,
                full    => full
            );
    END GENERATE g1;

END struct;




-- VHDL Entity RS232.serialPortTransmitter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:48 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortTransmitter IS
    GENERIC( 
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT( 
        TxD    : OUT    std_ulogic;
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic;
        busy   : OUT    std_ulogic
    );

-- Declarations

END serialPortTransmitter ;





-- library Common;
  use work.CommonLib.all;

architecture RTL of serialPortTransmitter is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal txData: std_ulogic_vector(dataBitNb-1 downto 0);
  signal send1: std_uLogic;
  signal txShiftEnable: std_uLogic;
  signal txShiftReg: std_ulogic_vector(dataBitNb+1 downto 0);
  signal txSendingByte: std_uLogic;
  signal txSendingByteAndStop: std_uLogic;

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterReset = '1' then
        dividerCounter <= to_unsigned(1, dividerCounter'length);
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter, send1)
  begin
    if dividerCounter = baudRateDivide then
      dividerCounterReset <= '1';
    elsif send1 = '1' then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  txShiftEnable <= dividerCounterReset;

  storeData: process(reset, clock)
  begin
    if reset = '1' then
      txData <= (others => '1');
    elsif rising_edge(clock) then
      if send = '1' then
        txData <= dataIn;
      end if;
    end if;
  end process storeData;

  delaySend: process(reset, clock)
  begin
    if reset = '1' then
      send1 <= '0';
    elsif rising_edge(clock) then
      send1 <= send;
    end if;
  end process delaySend;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      txShiftReg <= (others => '1');
    elsif rising_edge(clock) then
      if txShiftEnable = '1' then
        if send1 = '1' then
          txShiftReg <= '0' & txData & '0';
        else
          txShiftReg(txShiftReg'high-1 downto 0) <= txShiftReg(txShiftReg'high downto 1);
          txShiftReg(txShiftReg'high) <= '1';
        end if;
      end if;
    end if;
  end process shiftReg;

  txSendingByte <= '1' when (txShiftReg(txShiftReg'high downto 1) /= (txShiftReg'high downto 1 => '1'))
    else '0';

  txSendingByteAndStop <= '1' when txShiftReg /= (txShiftReg'high downto 0 => '1')
    else '0';

  TxD <= txShiftReg(0) when txSendingByte = '1' else '1';
  busy <= txSendingByteAndStop  or send1 or send;

end RTL;





--
-- VHDL Architecture RS232.serialPortFIFO.struct
--
-- Created:
--          by - francois.francois (Aphrodite)
--          at - 09:52:59 05/24/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

-- LIBRARY Memory;
-- LIBRARY RS232;

ARCHITECTURE struct OF serialPortFIFO IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL txSend      : std_ulogic;
    SIGNAL rxWord      : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL rxWordValid : std_ulogic;
    SIGNAL txFifoEmpty : std_ulogic;
    SIGNAL txWord      : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL txBusy      : std_ulogic;


    -- Component Declarations
    COMPONENT FIFO
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortReceiver
    GENERIC (
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT (
        RxD       : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortTransmitter
    GENERIC (
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT (
        TxD    : OUT    std_ulogic ;
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic ;
        busy   : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : FIFO USE ENTITY Memory.FIFO;
--     FOR ALL : serialPortReceiver USE ENTITY RS232.serialPortReceiver;
--     FOR ALL : serialPortTransmitter USE ENTITY RS232.serialPortTransmitter;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    process(reset, clock)
      begin
        if reset = '1' then
          txSend <= '0';
        elsif rising_edge(clock) then
          if ( (txFifoEmpty = '0') and (txBusy = '0') ) then
            txSend <= '1';
          else
            txSend <= '0';
          end if;
        end if;
      end process;
          


    -- Instance port mappings.
    I_rxFifo : FIFO
        GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => rxFifoDepth
        )
        PORT MAP (
            write   => rxWordValid,
            clock   => clock,
            reset   => reset,
            dataOut => rxData,
            read    => rxRd,
            dataIn  => rxWord,
            empty   => rxEmpty,
            full    => OPEN
        );
    I_txFifo : FIFO
        GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => txFifoDepth
        )
        PORT MAP (
            write   => txWr,
            clock   => clock,
            reset   => reset,
            dataOut => txWord,
            read    => txSend,
            dataIn  => txData,
            empty   => txFifoEmpty,
            full    => txFull
        );
    I_rx : serialPortReceiver
        GENERIC MAP (
            dataBitNb      => dataBitNb,
            baudRateDivide => baudRateDivide
        )
        PORT MAP (
            RxD       => RxD,
            clock     => clock,
            reset     => reset,
            dataOut   => rxWord,
            dataValid => rxWordValid
        );
    I_tx : serialPortTransmitter
        GENERIC MAP (
            dataBitNb      => dataBitNb,
            baudRateDivide => baudRateDivide
        )
        PORT MAP (
            TxD    => TxD,
            clock  => clock,
            reset  => reset,
            dataIn => txWord,
            send   => txSend,
            busy   => txBusy
        );

END struct;




--
-- VHDL Architecture GeneratorControl.frequencyRegulatorUart.struct
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:29:31 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

-- LIBRARY GeneratorControl;
-- LIBRARY RS232;

ARCHITECTURE struct OF frequencyRegulatorUart IS

    -- Architecture declarations
    constant uartBitNb : positive := 8;

    -- Internal signal declarations
    SIGNAL parallelOut : unsigned(controlAmplitude'high DOWNTO 0);
    SIGNAL rxData      : std_ulogic_vector(uartBitNb-1 DOWNTO 0);
    SIGNAL rxEmpty     : std_ulogic;
    SIGNAL rxRd        : std_ulogic;
    SIGNAL txData      : std_ulogic_vector(uartBitNb-1 DOWNTO 0);
    SIGNAL txFull      : std_ulogic;
    SIGNAL txWr        : std_ulogic;


    -- Component Declarations
    COMPONENT serDes
    GENERIC (
        parallelInBitNb  : positive := 8;
        parallelOutBitNb : positive := 8;
        serialPortBitNb  : integer  := 0
    );
    PORT (
        clock       : IN     std_ulogic ;
        parallelIn  : IN     signed (parallelInBitNb-1 DOWNTO 0);
        reset       : IN     std_ulogic ;
        rxData      : IN     std_ulogic_vector (serialPortBitNb-1 DOWNTO 0);
        rxEmpty     : IN     std_ulogic ;
        send        : IN     std_ulogic ;
        txFull      : IN     std_ulogic ;
        parallelOut : OUT    unsigned (parallelOutBitNb-1 DOWNTO 0);
        rxRd        : OUT    std_ulogic ;
        txData      : OUT    std_ulogic_vector (serialPortBitNb-1 DOWNTO 0);
        txWr        : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortFIFO
    GENERIC (
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        txFifoDepth    : positive := 8;
        rxFifoDepth    : positive := 8
    );
    PORT (
        RxD     : IN     std_ulogic ;
        TxD     : OUT    std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        rxEmpty : OUT    std_ulogic ;
        rxRd    : IN     std_ulogic ;
        rxData  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txFull  : OUT    std_ulogic ;
        txWr    : IN     std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : serDes USE ENTITY GeneratorControl.serDes;
--     FOR ALL : serialPortFIFO USE ENTITY RS232.serialPortFIFO;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    controlAmplitude <= unsigned(parallelOut);


    -- Instance port mappings.
    I_bytes : serDes
        GENERIC MAP (
            parallelInBitNb  => periodDiff'length,
            parallelOutBitNb => controlAmplitude'length,
            serialPortBitNb  => uartBitNb
        )
        PORT MAP (
            clock       => clock,
            parallelIn  => periodDiff,
            reset       => reset,
            rxData      => rxData,
            rxEmpty     => rxEmpty,
            send        => en,
            txFull      => txFull,
            parallelOut => parallelOut,
            rxRd        => rxRd,
            txData      => txData,
            txWr        => txWr
        );
    I_uart : serialPortFIFO
        GENERIC MAP (
            baudRateDivide => baudRateDivide,
            dataBitNb      => uartBitNb,
            txFifoDepth    => 1,
            rxFifoDepth    => 1
        )
        PORT MAP (
            RxD     => rxD,
            TxD     => txD,
            clock   => clock,
            reset   => reset,
            rxEmpty => rxEmpty,
            rxRd    => rxRd,
            rxData  => rxData,
            txData  => txData,
            txFull  => txFull,
            txWr    => txWr
        );

END struct;




--
-- VHDL Architecture GeneratorControl.frequencyRegulators.struct
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:30 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

-- LIBRARY GeneratorControl;

ARCHITECTURE struct OF frequencyRegulators IS

    -- Architecture declarations
    constant uartBitNb : positive := 8;

    -- Internal signal declarations
    SIGNAL controlAmplitudeI    : unsigned(controlAmplitudeBitNb-1 DOWNTO 0);
    SIGNAL controlAmplitudePI   : unsigned(controlAmplitudeBitNb-1 DOWNTO 0);
    SIGNAL controlAmplitudeUart : unsigned(controlAmplitudeBitNb-1 DOWNTO 0);
    SIGNAL enPI                 : std_ulogic;
    SIGNAL enUart               : std_ulogic;
    SIGNAL selI                 : std_ulogic;


    -- Component Declarations
    COMPONENT frequencyRegulatorI
    GENERIC (
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8
    );
    PORT (
        clock            : IN     std_ulogic ;
        en               : IN     std_ulogic ;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic ;
        sel              : IN     std_ulogic ;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT frequencyRegulatorPI
    GENERIC (
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        proportionalShift     : integer  := 0;
        integralShift         : integer  := 0
    );
    PORT (
        clock            : IN     std_ulogic ;
        en               : IN     std_ulogic ;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic ;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT frequencyRegulatorUart
    GENERIC (
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        baudRateDivide        : positive := 2083
    );
    PORT (
        clock            : IN     std_ulogic ;
        en               : IN     std_ulogic ;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic ;
        rxD              : IN     std_ulogic ;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        txD              : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : frequencyRegulatorI USE ENTITY GeneratorControl.frequencyRegulatorI;
--     FOR ALL : frequencyRegulatorPI USE ENTITY GeneratorControl.frequencyRegulatorPI;
--     FOR ALL : frequencyRegulatorUart USE ENTITY GeneratorControl.frequencyRegulatorUart;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    controlAmplitude <= controlAmplitudeI when regulationType = 2
      else controlAmplitudeUart when regulationType = 3
      else controlAmplitudePI;

    -- HDL Embedded Text Block 2 eb2
    enPI <= en when regulationType = 0
      else '0';
    
    selI <= '1' when regulationType = 2
      else '0';
    
    enUart <= en;


    -- Instance port mappings.
    I_I : frequencyRegulatorI
        GENERIC MAP (
            periodBitNb           => periodBitNb,
            controlAmplitudeBitNb => controlAmplitudeBitNb
        )
        PORT MAP (
            clock            => clock,
            en               => en,
            periodDiff       => periodDiff,
            reset            => reset,
            sel              => selI,
            controlAmplitude => controlAmplitudeI
        );
    I_PI : frequencyRegulatorPI
        GENERIC MAP (
            periodBitNb           => periodBitNb,
            controlAmplitudeBitNb => controlAmplitudeBitNb,
            proportionalShift     => proportionalShift,
            integralShift         => integralShift
        )
        PORT MAP (
            clock            => clock,
            en               => enPI,
            periodDiff       => periodDiff,
            reset            => reset,
            controlAmplitude => controlAmplitudePI
        );
    I_Uart : frequencyRegulatorUart
        GENERIC MAP (
            periodBitNb           => PeriodBitNb,
            controlAmplitudeBitNb => controlAmplitudeBitNb,
            baudRateDivide        => baudRateDivide
        )
        PORT MAP (
            clock            => clock,
            en               => enUart,
            periodDiff       => periodDiff,
            reset            => reset,
            rxD              => rxD,
            controlAmplitude => controlAmplitudeUart,
            txD              => txD
        );

END struct;




-- VHDL Entity GeneratorControl.ledDisplay.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 12:59:15 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY ledDisplay IS
    GENERIC( 
        phaseDifferenceBitNb : positive := 16;
        ledNb                : positive := 7
    );
    PORT( 
        phaseDifference : IN     signed (phaseDifferenceBitNb-1 DOWNTO 0);
        leds            : OUT    std_ulogic_vector (1 TO ledNb)
    );

-- Declarations

END ledDisplay ;





ARCHITECTURE RTL OF ledDisplay IS

  constant ledMiddle : positive := ledNb/2 + 1;
  constant bitThreshold1 : positive := 4;
  constant bitThreshold2 : positive := 8;

  signal levels: std_ulogic_vector(leds'range);

BEGIN
  ------------------------------------------------------------------------------
                                                                   -- middle LED
  levels(ledMiddle) <= '1' when phaseDifference = 0
    else '0';
  leds(ledMiddle) <= levels(ledMiddle);

  ------------------------------------------------------------------------------
                                                           -- LEDs around middle
  levels(ledMiddle-1) <= '1'
    when phaseDifference(phaseDifference'high downto bitThreshold1)+1 = 0
    else '0';
  levels(ledMiddle+1) <= '1'
    when phaseDifference(phaseDifference'high downto bitThreshold1) = 0
    else '0';
  leds(ledMiddle-1) <= levels(ledMiddle-1) or levels(ledMiddle);
  leds(ledMiddle+1) <= levels(ledMiddle+1) or levels(ledMiddle);

  ------------------------------------------------------------------------------
                                                                    -- next LEDs
  levels(ledMiddle-2) <= '1'
    when phaseDifference(phaseDifference'high downto bitThreshold2)+1 = 0
    else '0';
  levels(ledMiddle+2) <= '1'
    when phaseDifference(phaseDifference'high downto bitThreshold2) = 0
    else '0';
  leds(ledMiddle-2) <= levels(ledMiddle-2) or levels(ledMiddle-1) or levels(ledMiddle);
  leds(ledMiddle+2) <= levels(ledMiddle+2) or levels(ledMiddle+1) or levels(ledMiddle);

  ------------------------------------------------------------------------------
                                                                   -- outer LEDs
  levels(ledMiddle-3) <= '1' when
    (phaseDifference(phaseDifference'high) = '1') and
    (phaseDifference(phaseDifference'high downto bitThreshold2)+1 /= 0)
    else '0';
  levels(ledMiddle+3) <= '1' when
    (phaseDifference(phaseDifference'high) = '0') and
    (phaseDifference(phaseDifference'high downto bitThreshold2) /= 0)
    else '0';
  leds(ledMiddle-3) <= levels(ledMiddle-3);
  leds(ledMiddle+3) <= levels(ledMiddle+3);

END ARCHITECTURE RTL;




-- VHDL Entity GeneratorControl.manualControl.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 12:58:54 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY manualControl IS
    GENERIC( 
        controlAmplitudeBitNb : positive := 8
    );
    PORT( 
        clock            : IN     std_ulogic;
        decrement        : IN     std_ulogic;
        increment        : IN     std_ulogic;
        reset            : IN     std_ulogic;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );

-- Declarations

END manualControl ;





ARCHITECTURE RTL OF manualControl IS

  signal controlAmplitude_int: unsigned(controlAmplitude'range);

BEGIN
  accumulate: process(reset, clock)
  begin
    if reset = '1' then
      controlAmplitude_int <= (others => '0');
      controlAmplitude_int(controlAmplitude_int'high) <= '1';
    elsif rising_edge(clock) then
      if increment = '1' then
        controlAmplitude_int <= controlAmplitude_int + 1;
      elsif decrement = '1' then
        controlAmplitude_int <= controlAmplitude_int - 1;
      end if;
    end if;
  end process accumulate;

  controlAmplitude <= controlAmplitude_int;

END ARCHITECTURE RTL;




-- VHDL Entity GeneratorControl.phaseDetector.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 12:57:16 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY phaseDetector IS
    GENERIC( 
        periodBitNb          : positive := 12;
        phaseDifferenceBitNb : positive := 16;
        clockFrequency       : real     := 100.0E6;
        mainsFrequency       : real     := 50.0
    );
    PORT( 
        clock            : IN     std_ulogic;
        fbPhase          : IN     std_uLogic;
        refPhase         : IN     std_uLogic;
        reset            : IN     std_ulogic;
        noRefInput       : OUT    std_uLogic;
        periodDifference : OUT    signed (periodBitNb+1-1 DOWNTO 0);
        phaseDataValid   : OUT    std_uLogic;
        phaseDifference  : OUT    signed (phaseDifferenceBitNb-1 DOWNTO 0)
    );

-- Declarations

END phaseDetector ;





ARCHITECTURE masterVersion OF phaseDetector IS

  constant mainsCount: positive := integer(clockFrequency/mainsFrequency+0.5);
  signal refCount, fbCount, refPeriod, fbPeriod: unsigned(periodDifference'range);
  signal noInputRefCount: unsigned(refCount'range);
  signal noInput, noInputRefPhase, refPhaseMux: std_ulogic;
  signal fbPhaseDelayed1, fbPhaseDelayed2: std_ulogic;
  signal fbCountSampled: unsigned(refCount'range);
  signal phaseDiffwrapped, phaseDiffdelayed: signed(fbCountSampled'range);
  signal refPeriodSigned: signed(refPeriod'high+1 downto 0);
  signal unwrapOffset: signed(phaseDifference'range);

BEGIN
  ------------------------------------------------------------------------------
                                                         -- count signal periods
                                      -- count clock periods of reference signal
  countRefPeriod: process(reset, clock)
  begin
    if reset = '1' then
      refCount <= (others => '0');
    elsif rising_edge(clock) then
      if refPhase = '1' then
        refCount <= (others => '0');
      else
        refCount <= refCount + 1;
      end if;
    end if;
  end process countRefPeriod;

  ------------------------------------------------------------------------------
                                      -- simulate reference signal when no input
  countNoInputRefPeriod: process(reset, clock)
  begin
    if reset = '1' then
      noInputRefCount <= (others => '0');
    elsif rising_edge(clock) then
      if noInputRefPhase = '1' then
        noInputRefCount <= (others => '0');
      else
        noInputRefCount <= noInputRefCount + 1;
      end if;
    end if;
  end process countNoInputRefPeriod;

  noInputRefPhase <= '1' when noInputRefCount = mainsCount-1
    else '0';
                                          -- check for reference signal presence
  checkRefPeriod: process(reset, clock)
  begin
    if reset = '1' then
      noInput <= '0';
    elsif rising_edge(clock) then
      if signed(refCount)+1 = 0 then
        noInput <= '1';
      elsif refPhase = '1' then
        if abs(signed(refCount-mainsCount)) < mainsCount/10 then
          noInput <= '0';
        else
          noInput <= '1';
        end if;
      end if;
    end if;
  end process checkRefPeriod;

  refPhaseMux <= noInputRefPhase when noInput = '1'
    else refPhase;
  noRefInput <= noInput;

  ------------------------------------------------------------------------------
                                           -- calculate wrapped phase difference
                                                             -- store ref period
  storeRefPeriod: process(reset, clock)
  begin
    if reset = '1' then
      refPeriod <= (others => '0');
    elsif rising_edge(clock) then
      if refPhase = '1' then
        refPeriod <= refCount + 1;
      elsif (noInput = '1') and (noInputRefPhase = '1') then
        refPeriod <= noInputRefCount + 1;
      end if;
    end if;
  end process storeRefPeriod;
                                                              -- sample fb count
  sampleFbCount: process(reset, clock)
  begin
    if reset = '1' then
      fbCountSampled <= (others => '0');
    elsif rising_edge(clock) then
      if fbPhase = '1' then
        if noInput = '1' then
          fbCountSampled <= noInputRefCount;
        else
          fbCountSampled <= refCount;
        end if;
      end if;
    end if;
  end process sampleFbCount;
                                                  -- choose between lead and lag
  calcPhaseDiff: process(refPeriod, fbCountSampled)
  begin
    if fbCountSampled < refPeriod/2 then
      phaseDiffwrapped <= signed(fbCountSampled);
    else
      phaseDiffwrapped <= signed(fbCountSampled - refPeriod);
    end if;
  end process calcPhaseDiff;

  ------------------------------------------------------------------------------
                                                      -- unwrap phase difference
                                                            -- delay phase pulse
  delayFbPhase: process(reset, clock)
  begin
    if reset = '1' then
      fbPhaseDelayed1 <= '0';
      fbPhaseDelayed2 <= '0';
    elsif rising_edge(clock) then
      fbPhaseDelayed1 <= fbPhase;
      fbPhaseDelayed2 <= fbPhaseDelayed1;
    end if;
  end process delayFbPhase;
                                                       -- delay phase difference
  delayPhaseDifference: process(reset, clock)
  begin
    if reset = '1' then
      phaseDiffdelayed <= (others => '0');
    elsif rising_edge(clock) then
      if fbPhase = '1' then
        phaseDiffdelayed <= phaseDiffwrapped;
      end if;
    end if;
  end process delayPhaseDifference;
                                    -- transform refperiod to signed (add 1 MSB)
  refPeriodSigned <= signed(resize(refPeriod, refPeriodSigned'length));
                                                            -- unwrapping offset
  updateOffset: process(reset, clock)
  begin
    if reset = '1' then
      unwrapOffset <= (others => '0');
    elsif rising_edge(clock) then
      if fbPhaseDelayed1 = '1' then
                                                                -- negative jump
        if phaseDiffwrapped - phaseDiffdelayed < -3*refPeriodSigned/4 then
          unwrapOffset <= unwrapOffset + refPeriodSigned;
        end if;
                                                                -- positive jump
        if phaseDiffwrapped - phaseDiffdelayed > 3*refPeriodSigned/4 then
          unwrapOffset <= unwrapOffset - refPeriodSigned;
        end if;
      end if;
    end if;
  end process updateOffset;
                                                        -- add offset and sample
  addOffset: process(reset, clock)
  begin
    if reset = '1' then
      phaseDifference <= (others => '0');
    elsif rising_edge(clock) then
      if fbPhaseDelayed2 = '1' then
        phaseDifference <= unwrapOffset + phaseDiffwrapped;
      end if;
    end if;
  end process addOffset;
                                               -- assert data valid on ref pulse
  delayDataValid: process(reset, clock)
  begin
    if reset = '1' then
      phaseDataValid <= '0';
    elsif rising_edge(clock) then
      phaseDataValid <= refPhaseMux;
    end if;
  end process delayDataValid;

  ------------------------------------------------------------------------------
                                                  -- calculate period difference
                                          -- count clock periods of phase signal
  countfbPeriod: process(reset, clock)
  begin
    if reset = '1' then
      fbCount <= (others => '0');
    elsif rising_edge(clock) then
      if fbPhase = '1' then
        fbCount <= (others => '0');
      else
        fbCount <= fbCount + 1;
      end if;
    end if;
  end process countfbPeriod;
                                                              -- store fb period
  storeFbPeriod: process(reset, clock)
  begin
    if reset = '1' then
      fbPeriod <= (others => '0');
    elsif rising_edge(clock) then
                                                         -- store when new pulse
      if fbPhase = '1' then
        fbPeriod <= fbCount + 1;
                                                         -- saturate on overflow
      elsif signed(fbCount)+1 = 0 then
        fbPeriod <= fbCount;
      end if;
    end if;
  end process storeFbPeriod;

  periodDifference <= signed(
    resize(fbPeriod, periodDifference'length) -
    resize(refPeriod, periodDifference'length)
  );

END ARCHITECTURE masterVersion;




-- VHDL Entity GeneratorControl.phaseRegulator.symbol
--
-- Created:
--          by - francois.corthay.UNKNOWN (WE2330806)
--          at - 11:46:49 26.10.2022
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY phaseRegulator IS
    GENERIC( 
        phaseDifferenceBitNb  : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        proportionalShift     : integer  := 0;
        integratorShift       : integer  := 0
    );
    PORT( 
        clock            : IN     std_ulogic;
        en               : IN     std_ulogic;
        phaseDiff        : IN     signed (phaseDifferenceBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );

-- Declarations

END phaseRegulator ;





ARCHITECTURE PID OF phaseRegulator IS

  constant outputOffset: unsigned(controlAmplitude'range)
    := shift_left(resize("1", controlAmplitude'length), controlAmplitude'length-1);

  constant proportionalBitNb: positive := controlAmplitude'length;
  signal proportionalShifted: signed(phaseDiff'length+proportionalShift-1 downto 0);
  signal proportionalOverflow: std_ulogic;
  signal proportional: signed(proportionalBitNb-1 downto 0);

  constant integratorBitNb: positive := controlAmplitude'length;
  signal integrator: signed(integratorBitNb-1 downto 0);

BEGIN
  ------------------------------------------------------------------------------
                                                            -- proportional term
--  proportionalShifted <= shift_left(
--    resize(phaseDiff, proportionalShifted'length),
--    proportionalShift
--  );
--
--  proportionalOverflow <= '0' when shift_right(proportionalShifted, phaseDiff'length) = 0
--    else '0' when shift_right(proportionalShifted, phaseDiff'length)+1 = 0
--    else '1';
--
--  limitOverflow: process(proportionalOverflow, proportionalShifted)
--  begin
--    if proportionalOverflow = '0' then
--      proportional <= resize(
--        shift_right(
--          proportionalShifted,
--          phaseDiff'length - proportional'length
--        ),
--        proportional'length
--      );
--    else
--      proportional <= (others => not proportionalShifted(proportionalShifted'high));
--      proportional(proportional'high) <= proportionalShifted(proportionalShifted'high);
--    end if;
--  end process limitOverflow;

  ------------------------------------------------------------------------------
                                                              -- integrator term
--  updateIntegratorTerm: process(reset, clock)
--  begin
--    if reset = '1' then
--      integrator <= (others => '0');
--    elsif rising_edge(clock) then
--      if en = '1' then
--        if phaseDiff > 0 then
--          integrator <= integrator + integratorShift;
--        elsif phaseDiff < 0 then
--          integrator <= integrator - integratorShift;
--        end if;
--      end if;
--    end if;
--  end process updateIntegratorTerm;

  ------------------------------------------------------------------------------
                                                             -- regulator output
  controlAmplitude <= outputOffset;
--  controlAmplitude <= outputOffset + unsigned(proportional + integrator);

END ARCHITECTURE PID;




-- VHDL Entity GeneratorControl.pwmModulator.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 12:56:11 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY pwmModulator IS
    GENERIC( 
        amplitudeBitNb : positive := 8;
        dividerBitNb   : natural  := 1E3
    );
    PORT( 
        amplitude   : IN     unsigned (amplitudeBitNb-1 DOWNTO 0);
        amplitudeEn : IN     std_ulogic;
        clock       : IN     std_ulogic;
        reset       : IN     std_ulogic;
        pwm         : OUT    std_ulogic
    );

-- Declarations

END pwmModulator ;





ARCHITECTURE masterVersion OF pwmModulator IS

  signal divideCount: unsigned(dividerBitNb-amplitude'length-1 downto 0);
  signal pwmEn: std_ulogic;
  signal amplitudeReg, sawtooth: unsigned(amplitude'range);

BEGIN
  ------------------------------------------------------------------------------
                                                          -- store new amplitude
  storeAmplitude: process(reset, clock)
  begin
    if reset = '1' then
      amplitudeReg <= (others => '0');
    elsif rising_edge(clock) then
      if amplitudeEn = '1' then
        if amplitude(amplitude'high downto amplitude'high-2) /= "111" then
          amplitudeReg <= amplitude;
        end if;
      end if;
    end if;
  end process storeAmplitude;

  ------------------------------------------------------------------------------
                                       -- generate enable pulse for PWM sawtooth
  generatePrescaler: if dividerBitNb > amplitude'length generate

    divideClockFrequency: process(reset, clock)
    begin
      if reset = '1' then
        divideCount <= (others => '0');
      elsif rising_edge(clock) then
        divideCount <= divideCount + 1;
      end if;
    end process divideClockFrequency;

    pwmEn <= '1' when divideCount = 0
      else '0';

  end generate generatePrescaler;
                                                -- no prescaler if not necessary

  alwaysEnable: if dividerBitNb <= amplitude'length generate
    pwmEn <= '1';
  end generate alwaysEnable;

  ------------------------------------------------------------------------------
                                             -- PWM with sawtooth and comparator
  buildSawtooth: process(reset, clock)
  begin
    if reset = '1' then
      sawtooth <= (others => '0');
    elsif rising_edge(clock) then
      if pwmEn = '1' then
        sawtooth <= sawtooth + 1;
      end if;
    end if;
  end process buildSawtooth;

  pwm <= '1' when amplitudeReg > sawtooth
    else '0';

END ARCHITECTURE masterVersion;




-- VHDL Entity GeneratorControl.risingDetector.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 12:43:11 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY risingDetector IS
    PORT( 
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        sigIn  : IN     std_ulogic;
        rising : OUT    std_uLogic
    );

-- Declarations

END risingDetector ;





ARCHITECTURE masterVersion OF risingDetector IS

  signal sigInDelayed: std_ulogic;

BEGIN
  ------------------------------------------------------------------------------
                                                                  -- delay input
  delayInput: process(reset, clock)
  begin
    if reset = '1' then
      sigInDelayed <= '0';
    elsif rising_edge(clock) then
      sigInDelayed <= sigIn;
    end if;
  end process delayInput;

  ------------------------------------------------------------------------------
                                                                  -- find change
  rising <= '1' when (sigIn = '1') and (sigInDelayed = '0')
    else '0';

END ARCHITECTURE masterVersion;




-- VHDL Entity GeneratorControl.controlSelector.symbol
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 13:02:45 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY controlSelector IS
    GENERIC( 
        controlAmplitudeBitNb : positive := 8;
        periodBitNb           : positive := 8
    );
    PORT( 
        clock            : IN     std_ulogic;
        frequencyRegVal  : IN     unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        manualVal        : IN     unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        periodDifference : IN     signed (periodBitNb-1 DOWNTO 0);
        phaseRegVal      : IN     unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic;
        selectManual     : IN     std_ulogic;
        amplitude        : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );

-- Declarations

END controlSelector ;





ARCHITECTURE RTL OF controlSelector IS

BEGIN
  ------------------------------------------------------------------------------
                                                                 -- select input
  selectInput: process(
    selectManual, periodDifference,
    phaseRegVal, frequencyRegVal, manualVal
  )
  begin
    if selectManual = '1' then
      amplitude <= manualVal;
    else
      amplitude <= frequencyRegVal;
    end if;
  end process selectInput;

END ARCHITECTURE RTL;




--
-- VHDL Architecture GeneratorControl.generatorControl.masterVersion
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:30 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

-- LIBRARY GeneratorControl;

ARCHITECTURE masterVersion OF generatorControl IS

    -- Architecture declarations
    constant periodBitNb: positive := requiredBitNb(integer(clockFrequency/mainsFrequency)) + 1;
    constant phaseDifferenceBitNb: positive := periodBitNb + 2;
    constant pwmDivideBitNb: positive := requiredBitNb(integer(clockFrequency/pwmFrequency));

    -- Internal signal declarations
    SIGNAL amplitudeEn          : std_ulogic;
    SIGNAL buttonCounterDone    : std_ulogic;
    SIGNAL controlAmplitude     : unsigned(controlAmplitudeBitNb-1 DOWNTO 0);
    SIGNAL decrementControl     : std_ulogic;
    SIGNAL frequencyControlVal  : unsigned(controlAmplitudeBitNb-1 DOWNTO 0);
    SIGNAL generatorRising      : std_uLogic;
    SIGNAL incrementControl     : std_ulogic;
    SIGNAL logic1               : std_ulogic;
    SIGNAL mainsRising          : std_uLogic;
    SIGNAL namualControlVal     : unsigned(controlAmplitudeBitNb-1 DOWNTO 0);
    SIGNAL noRefInput           : std_uLogic;
    SIGNAL periodDifference     : signed(periodBitNb+1-1 DOWNTO 0);
    SIGNAL phaseControlVal      : unsigned(controlAmplitudeBitNb-1 DOWNTO 0);
    SIGNAL phaseDataValid       : std_uLogic;
    SIGNAL phaseDiffUnsigned    : unsigned(phaseDifferenceBitNb-1 DOWNTO 0);
    SIGNAL phaseDifference      : signed(phaseDifferenceBitNb-1 DOWNTO 0);
    SIGNAL pwmPhaseDiff         : std_uLogic;
    SIGNAL regulationType       : unsigned(1 DOWNTO 0);
    SIGNAL restartButtonCounter : std_ulogic;
    SIGNAL selectManual         : std_ulogic;


    -- Component Declarations
    COMPONENT buttonControl
    PORT (
        clock          : IN     std_ulogic ;
        counterDone    : IN     std_ulogic ;
        decrease       : IN     std_ulogic ;
        increase       : IN     std_ulogic ;
        reset          : IN     std_ulogic ;
        selectToggle   : IN     std_ulogic ;
        decrement      : OUT    std_ulogic ;
        increment      : OUT    std_ulogic ;
        restartCounter : OUT    std_ulogic ;
        selectManual   : OUT    std_ulogic ;
        selectRegType  : OUT    unsigned (1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT buttonRepeatCounter
    GENERIC (
        clockFrequency  : real := 100.0E6;
        repeatFrequency : real := 0.5
    );
    PORT (
        clock          : IN     std_ulogic ;
        reset          : IN     std_ulogic ;
        restartCounter : IN     std_ulogic ;
        counterDone    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT controlSelector
    GENERIC (
        controlAmplitudeBitNb : positive := 8;
        periodBitNb           : positive := 8
    );
    PORT (
        clock            : IN     std_ulogic ;
        frequencyRegVal  : IN     unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        manualVal        : IN     unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        periodDifference : IN     signed (periodBitNb-1 DOWNTO 0);
        phaseRegVal      : IN     unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic ;
        selectManual     : IN     std_ulogic ;
        amplitude        : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT frequencyRegulators
    GENERIC (
        periodBitNb           : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        proportionalShift     : integer  := 0;
        integralShift         : integer  := 0;
        baudRateDivide        : positive := 2083
    );
    PORT (
        clock            : IN     std_ulogic ;
        en               : IN     std_ulogic ;
        periodDiff       : IN     signed (periodBitNb-1 DOWNTO 0);
        regulationType   : IN     unsigned (1 DOWNTO 0);
        reset            : IN     std_ulogic ;
        rxD              : IN     std_ulogic ;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0);
        txD              : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT ledDisplay
    GENERIC (
        phaseDifferenceBitNb : positive := 16;
        ledNb                : positive := 7
    );
    PORT (
        phaseDifference : IN     signed (phaseDifferenceBitNb-1 DOWNTO 0);
        leds            : OUT    std_ulogic_vector (1 TO ledNb)
    );
    END COMPONENT;
    COMPONENT manualControl
    GENERIC (
        controlAmplitudeBitNb : positive := 8
    );
    PORT (
        clock            : IN     std_ulogic ;
        decrement        : IN     std_ulogic ;
        increment        : IN     std_ulogic ;
        reset            : IN     std_ulogic ;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT phaseDetector
    GENERIC (
        periodBitNb          : positive := 12;
        phaseDifferenceBitNb : positive := 16;
        clockFrequency       : real     := 100.0E6;
        mainsFrequency       : real     := 50.0
    );
    PORT (
        clock            : IN     std_ulogic ;
        fbPhase          : IN     std_uLogic ;
        refPhase         : IN     std_uLogic ;
        reset            : IN     std_ulogic ;
        noRefInput       : OUT    std_uLogic ;
        periodDifference : OUT    signed (periodBitNb+1-1 DOWNTO 0);
        phaseDataValid   : OUT    std_uLogic ;
        phaseDifference  : OUT    signed (phaseDifferenceBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT phaseRegulator
    GENERIC (
        phaseDifferenceBitNb  : positive := 16;
        controlAmplitudeBitNb : positive := 8;
        proportionalShift     : integer  := 0;
        integratorShift       : integer  := 0
    );
    PORT (
        clock            : IN     std_ulogic ;
        en               : IN     std_ulogic ;
        phaseDiff        : IN     signed (phaseDifferenceBitNb-1 DOWNTO 0);
        reset            : IN     std_ulogic ;
        controlAmplitude : OUT    unsigned (controlAmplitudeBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT pwmModulator
    GENERIC (
        amplitudeBitNb : positive := 8;
        dividerBitNb   : natural  := 1E3
    );
    PORT (
        amplitude   : IN     unsigned (amplitudeBitNb-1 DOWNTO 0);
        amplitudeEn : IN     std_ulogic ;
        clock       : IN     std_ulogic ;
        reset       : IN     std_ulogic ;
        pwm         : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT risingDetector
    PORT (
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        sigIn  : IN     std_ulogic ;
        rising : OUT    std_uLogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : buttonControl USE ENTITY GeneratorControl.buttonControl;
--     FOR ALL : buttonRepeatCounter USE ENTITY GeneratorControl.buttonRepeatCounter;
--     FOR ALL : controlSelector USE ENTITY GeneratorControl.controlSelector;
--     FOR ALL : frequencyRegulators USE ENTITY GeneratorControl.frequencyRegulators;
--     FOR ALL : ledDisplay USE ENTITY GeneratorControl.ledDisplay;
--     FOR ALL : manualControl USE ENTITY GeneratorControl.manualControl;
--     FOR ALL : phaseDetector USE ENTITY GeneratorControl.phaseDetector;
--     FOR ALL : phaseRegulator USE ENTITY GeneratorControl.phaseRegulator;
--     FOR ALL : pwmModulator USE ENTITY GeneratorControl.pwmModulator;
--     FOR ALL : risingDetector USE ENTITY GeneratorControl.risingDetector;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    phaseDiffUnsigned <= unsigned(phaseDifference);
    logic1 <= '1';

    -- HDL Embedded Text Block 2 eb2
    amplitudeEn <= phaseDataValid or selectManual;

    -- HDL Embedded Text Block 3 eb3
    process(controlAmplitude)
    begin
    
      testOut(1) <= regulationType(1);
      testOut(2) <= regulationType(0);
    
      testOut(3) <= noRefInput;
      testOut(4) <= mains;
      testOut(5) <= mainsRising;
      testOut(6) <= generator;
      testOut(7) <= generatorRising;
    
      for index in 0 to 7 loop
        testOut(testOut'high-index) <= periodDifference(periodDifference'high-index);
      end loop;
    
    end process;


    -- Instance port mappings.
    I_buttons : buttonControl
        PORT MAP (
            clock          => clock,
            counterDone    => buttonCounterDone,
            decrease       => buttons(2),
            increase       => buttons(3),
            reset          => reset,
            selectToggle   => buttons(1),
            decrement      => decrementControl,
            increment      => incrementControl,
            restartCounter => restartButtonCounter,
            selectManual   => selectManual,
            selectRegType  => regulationType
        );
    I_buttCnt : buttonRepeatCounter
        GENERIC MAP (
            clockFrequency  => clockFrequency,
            repeatFrequency => buttonsRepeatFrequency
        )
        PORT MAP (
            clock          => clock,
            reset          => reset,
            restartCounter => restartButtonCounter,
            counterDone    => buttonCounterDone
        );
    I_sel : controlSelector
        GENERIC MAP (
            controlAmplitudeBitNb => controlAmplitudeBitNb,
            periodBitNb           => periodBitNb+1
        )
        PORT MAP (
            clock            => clock,
            frequencyRegVal  => frequencyControlVal,
            manualVal        => namualControlVal,
            periodDifference => periodDifference,
            phaseRegVal      => phaseControlVal,
            reset            => reset,
            selectManual     => selectManual,
            amplitude        => controlAmplitude
        );
    I_fReg : frequencyRegulators
        GENERIC MAP (
            periodBitNb           => periodBitNb+1,
            controlAmplitudeBitNb => controlAmplitudeBitNb,
            proportionalShift     => proportionalShift,
            integralShift         => proportionalShift,
            baudRateDivide        => integer(clockFrequency/rs232BaudRate+0.5)
        )
        PORT MAP (
            clock            => clock,
            en               => phaseDataValid,
            periodDiff       => periodDifference,
            regulationType   => regulationType,
            reset            => reset,
            rxD              => RxD,
            controlAmplitude => frequencyControlVal,
            txD              => TxD
        );
    I_LEDs : ledDisplay
        GENERIC MAP (
            phaseDifferenceBitNb => phaseDifferenceBitNb,
            ledNb                => ledNb
        )
        PORT MAP (
            phaseDifference => phaseDifference,
            leds            => leds
        );
    I_man : manualControl
        GENERIC MAP (
            controlAmplitudeBitNb => controlAmplitudeBitNb
        )
        PORT MAP (
            clock            => clock,
            decrement        => decrementControl,
            increment        => incrementControl,
            reset            => reset,
            controlAmplitude => namualControlVal
        );
    I_PD : phaseDetector
        GENERIC MAP (
            periodBitNb          => periodBitNb,
            phaseDifferenceBitNb => phaseDifferenceBitNb,
            clockFrequency       => clockFrequency,
            mainsFrequency       => mainsFrequency
        )
        PORT MAP (
            clock            => clock,
            fbPhase          => generatorRising,
            refPhase         => mainsRising,
            reset            => reset,
            noRefInput       => noRefInput,
            periodDifference => periodDifference,
            phaseDataValid   => phaseDataValid,
            phaseDifference  => phaseDifference
        );
    I_phReg : phaseRegulator
        GENERIC MAP (
            phaseDifferenceBitNb  => phaseDifferenceBitNb,
            controlAmplitudeBitNb => controlAmplitudeBitNb,
            proportionalShift     => proportionalShift,
            integratorShift       => integratorShift
        )
        PORT MAP (
            clock            => clock,
            en               => phaseDataValid,
            phaseDiff        => phaseDifference,
            reset            => reset,
            controlAmplitude => phaseControlVal
        );
    I_PWM : pwmModulator
        GENERIC MAP (
            amplitudeBitNb => controlAmplitudeBitNb,
            dividerBitNb   => pwmDivideBitNb
        )
        PORT MAP (
            amplitude   => controlAmplitude,
            amplitudeEn => amplitudeEn,
            clock       => clock,
            reset       => reset,
            pwm         => pwm
        );
    I_PWM1 : pwmModulator
        GENERIC MAP (
            amplitudeBitNb => phaseDifferenceBitNb,
            dividerBitNb   => phaseDifferenceBitNb+1
        )
        PORT MAP (
            amplitude   => phaseDiffUnsigned,
            amplitudeEn => logic1,
            clock       => clock,
            reset       => reset,
            pwm         => pwmPhaseDiff
        );
    I_riseG : risingDetector
        PORT MAP (
            clock  => clock,
            reset  => reset,
            sigIn  => generator,
            rising => generatorRising
        );
    I_riseM : risingDetector
        PORT MAP (
            clock  => clock,
            reset  => reset,
            sigIn  => mains,
            rising => mainsRising
        );

END masterVersion;




-- VHDL Entity Common.debouncerULogicVector.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:43:38 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

ENTITY debouncerULogicVector IS
    GENERIC( 
        inputBitNb   : positive   := 8;
        counterBitNb : positive   := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT( 
        clock     : IN     std_ulogic;
        input     : IN     std_ulogic_vector (1 TO inputBitNb);
        reset     : IN     std_ulogic;
        debounced : OUT    std_ulogic_vector (1 TO inputBitNb)
    );

-- Declarations

END debouncerULogicVector ;





-- filename:          debouncer.vhd
-- kind:              vhdl file
-- first created:     05.03.2012
-- created by:        zas
--------------------------------------------------------------------------------
-- History:
-- v0.1 : zas 05.03.2012 -- Initial Version
-- v0.2 : cof 22.01.2013 -- synchronization to clock
--------------------------------------------------------------------------------
-- Description: 
-- Debounces a button on both edges.
--             _   _   ____________________   _   _
-- input  ____/ \_/ \_/                    \_/ \_/ \______
--              _____________________________
-- output _____/                             \____________
--
--------------------------------------------------------------------------------

ARCHITECTURE rtl OF debouncerULogicVector IS
 
  signal inputNormal : std_ulogic_vector(input'range);
  signal inputSynch, inputDelayed, inputChanged : std_ulogic;
  signal debounceCounter : unsigned(counterBitNb-1 downto 0);
 
BEGIN
  ------------------------------------------------------------------------------
                                                               -- adapt polarity
  adaptPolarity: process(input)
  begin
    for index in input'range loop
      inputNormal(index) <= input(index) xor invertInput;
    end loop;
  end process adaptPolarity;

  ------------------------------------------------------------------------------
                                                   -- Synchronize input to clock
  synchInput: process(reset, clock)
    variable inputOr : std_ulogic;
  begin
    if reset = '1' then
      inputSynch <= '0';
    elsif rising_edge(clock) then
      inputOr := '0';
      for index in input'range loop
        inputOr := inputOr or inputNormal(index);
      end loop;
      inputSynch <= inputOr;
    end if;
  end process synchInput;

  ------------------------------------------------------------------------------
                                                           -- Find edge on input
  delayInput: process(reset, clock)
  begin
    if reset = '1' then
      inputDelayed <= '0';
    elsif rising_edge(clock) then
      inputDelayed <= inputSynch;
    end if;
  end process delayInput;

  inputChanged <= '1' when inputDelayed /= inputSynch
    else '0';

  ------------------------------------------------------------------------------
                                                             -- Debounce counter
  countDeadTime: process(reset, clock)
  begin
    if reset = '1' then
      debounceCounter <= (others => '0');
    elsif rising_edge(clock) then
      if debounceCounter = 0 then
        if inputChanged = '1' then
          debounceCounter <= debounceCounter - 1;
        end if;
      else
        debounceCounter <= debounceCounter - 1;
      end if;
    end if;
  end process countDeadTime;

  ------------------------------------------------------------------------------
                                                                -- Update output
  updateOutput: process(reset, clock)
  begin
    if reset = '1' then
      debounced <= (others => '0');
    elsif rising_edge(clock) then
      if (inputChanged = '1') and (debounceCounter = 0) then
        debounced <= inputNormal;
      elsif debounceCounter = 1 then
        debounced <= inputNormal;
      end if;
    end if;
  end process updateOutput;
 
END ARCHITECTURE rtl;




-- VHDL Entity Common.spikeFilter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:43:38 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

ENTITY spikeFilter IS
    GENERIC( 
        counterBitNb : positive   := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT( 
        clock    : IN     std_ulogic;
        input    : IN     std_ulogic;
        reset    : IN     std_ulogic;
        filtered : OUT    std_ulogic
    );

-- Declarations

END spikeFilter ;





--------------------------------------------------------------------------------
-- Description: 
-- Filters short time spikes.
--             _   _   ____________________   _   _
-- input  ____/ \_/ \_/                    \_/ \_/ \_________________
--                         _____________________________
-- output ________________/                             \____________
--
--------------------------------------------------------------------------------

ARCHITECTURE rtl OF spikeFilter IS
 
  signal filterCounter : unsigned(counterBitNb-1 downto 0);
  signal inputSynch, inputDelayed, inputChanged : std_ulogic;
 
BEGIN
  ------------------------------------------------------------------------------
                                                   -- Synchronize input to clock
  synchInput: process(reset, clock)
  begin
    if reset = '1' then
      inputSynch <= '0';
    elsif rising_edge(clock) then
      inputSynch <= input xor invertInput;
    end if;
  end process synchInput;

  ------------------------------------------------------------------------------
                                                           -- Find edge on input
  delayInput: process(reset, clock)
  begin
    if reset = '1' then
      inputDelayed <= '0';
    elsif rising_edge(clock) then
      inputDelayed <= inputSynch;
    end if;
  end process delayInput;

  inputChanged <= '1' when inputDelayed /= inputSynch
    else '0';

  ------------------------------------------------------------------------------
                                                             -- Debounce counter
  countDeadTime: process(reset, clock)
  begin
    if reset = '1' then
      filterCounter <= (others => '0');
    elsif rising_edge(clock) then
      if filterCounter = 0 then
        if inputChanged = '1' then
          filterCounter <= filterCounter + 1;
        end if;
      elsif signed(filterCounter)+1 = 0 then
        if inputChanged = '1' then
          filterCounter <= filterCounter - 1;
        end if;
      else
        if inputSynch = '0' then
          filterCounter <= filterCounter - 1;
        else
          filterCounter <= filterCounter + 1;
        end if;
      end if;
    end if;
  end process countDeadTime;

  ------------------------------------------------------------------------------
                                                                -- Update output
  updateOutput: process(reset, clock)
  begin
    if reset = '1' then
      filtered <= '0';
    elsif rising_edge(clock) then
      if filterCounter = 0 then
        filtered <= '0';
      elsif signed(filterCounter)+1 = 0 then
        filtered <= '1';
      end if;
    end if;
  end process updateOutput;
 
END ARCHITECTURE rtl;




-- VHDL Entity sequential.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:46:19 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY DFF IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0' after delay;
    elsif rising_edge(clk) then
      q <= d after delay;
    end if;
  end process;

END sim;




-- VHDL Entity sequential.registerULogicVectorTo.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:46:42 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;

ENTITY registerULogicVectorTo IS
    GENERIC( 
        delay         : time     := gateDelay;
        registerBitNb : positive := 8
    );
    PORT( 
        clock   : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        enable  : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (registerBitNb-1 DOWNTO 0)
    );

-- Declarations

END registerULogicVectorTo ;





ARCHITECTURE sim OF registerULogicVectorTo IS
BEGIN

  registerData: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0') after delay;
    elsif rising_edge(clock) then
      if enable = '1' then
        dataOut <= dataIn after delay;
      end if;
    end if;
  end process registerData;

END ARCHITECTURE sim;





--
-- VHDL Architecture Board.FPGA_generatorControl.struct
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 16:05:27 10/13/20
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
-- LIBRARY gates;
  use work.gates.all;
-- LIBRARY Common;
  use work.CommonLib.all;

-- LIBRARY GeneratorControl;
-- LIBRARY sequential;

ARCHITECTURE struct OF FPGA_generatorControl IS

    -- Architecture declarations
    constant clockFrequency: real := 66.0E6;
    constant rs232BaudRate: real := 115.2E3;
    constant pwmFrequency: real := 100.0E3;
    constant mainsFrequency: real := 50.0;
    constant debounceCounterBitNb: positive := requiredBitNb(integer(clockFrequency/100.0));
    constant spikeFilterCounterBitNb: positive := requiredBitNb(10);
    constant buttonsRepeatFrequency: real := 100.0;
    constant controlAmplitudeBitNb: natural := 10;
    constant proportionalShift: integer := -14;
    constant integratorShift: integer := -12;
    constant testLineNb: positive := 16;

    -- Internal signal declarations
    SIGNAL LEDs           : std_uLogic_vector(1 TO ledNb);
    SIGNAL RxDSynch       : std_ulogic;
    SIGNAL buttons        : std_uLogic_vector(1 TO buttonNb);
    SIGNAL buttonsSynch   : std_uLogic_vector(1 TO buttonNb);
    SIGNAL generatorSynch : std_uLogic;
    SIGNAL logic_1        : std_uLogic;
    SIGNAL mainsSynch     : std_uLogic;
    SIGNAL reset          : std_ulogic;
    SIGNAL reset1         : std_ulogic;
    SIGNAL resetSynch     : std_ulogic;
    SIGNAL resetSynch_n   : std_ulogic;
    SIGNAL testOut        : std_uLogic_vector(1 TO testLineNb);


    -- Component Declarations
    COMPONENT debouncerULogicVector
    GENERIC (
        inputBitNb   : positive   := 8;
        counterBitNb : positive   := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT (
        clock     : IN     std_ulogic ;
        input     : IN     std_ulogic_vector (1 TO inputBitNb);
        reset     : IN     std_ulogic ;
        debounced : OUT    std_ulogic_vector (1 TO inputBitNb)
    );
    END COMPONENT;
    COMPONENT spikeFilter
    GENERIC (
        counterBitNb : positive   := 18;
        invertInput  : std_ulogic := '0'
    );
    PORT (
        clock    : IN     std_ulogic ;
        input    : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        filtered : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT bufferUlogic
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverter
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT generatorControl
    GENERIC (
        clockFrequency         : real     := 66.0E6;
        rs232BaudRate          : real     := 115.2E3;
        pwmFrequency           : real     := 100.0E3;
        mainsFrequency         : real     := 50.0;
        buttonsRepeatFrequency : real     := 0.5;
        controlAmplitudeBitNb  : positive := 10;
        proportionalShift      : integer  := 8;
        integratorShift        : integer  := 1;
        buttonNb               : positive := 4;
        ledNb                  : positive := 7;
        testLineNb             : positive := 8
    );
    PORT (
        RxD       : IN     std_ulogic ;
        buttons   : IN     std_uLogic_vector (1 TO buttonNb);
        clock     : IN     std_ulogic ;
        generator : IN     std_uLogic ;
        mains     : IN     std_uLogic ;
        reset     : IN     std_ulogic ;
        TxD       : OUT    std_ulogic ;
        leds      : OUT    std_uLogic_vector (1 TO ledNb);
        pwm       : OUT    std_uLogic ;
        testOut   : OUT    std_uLogic_vector (1 TO testLineNb)
    );
    END COMPONENT;
    COMPONENT DFF
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT registerULogicVectorTo
    GENERIC (
        delay         : time     := gateDelay;
        registerBitNb : positive := 8
    );
    PORT (
        clock   : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (registerBitNb-1 DOWNTO 0);
        enable  : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (registerBitNb-1 DOWNTO 0)
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
--     FOR ALL : DFF USE ENTITY sequential.DFF;
--     FOR ALL : bufferUlogic USE ENTITY gates.bufferUlogic;
--     FOR ALL : debouncerULogicVector USE ENTITY Common.debouncerULogicVector;
--     FOR ALL : generatorControl USE ENTITY GeneratorControl.generatorControl;
--     FOR ALL : inverter USE ENTITY gates.inverter;
--     FOR ALL : logic1 USE ENTITY gates.logic1;
--     FOR ALL : registerULogicVectorTo USE ENTITY sequential.registerULogicVectorTo;
--     FOR ALL : spikeFilter USE ENTITY Common.spikeFilter;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    LEDS_n <= not LEDs;
    -- LEDS_n <= not testOut(8 to 15);
    -- LEDS_n(buttonNb+1 to ledNb) <= not LEDs(buttonNb+1 to ledNb);
    -- LEDS_n(1 to buttonNb) <= not buttonsSynch;

    -- HDL Embedded Text Block 2 eb2
    test <= testOut(1 to 10);


    -- Instance port mappings.
    I_debounce : debouncerULogicVector
        GENERIC MAP (
            inputBitNb   => buttonNb,
            counterBitNb => debounceCounterBitNb,
            invertInput  => '1'
        )
        PORT MAP (
            clock     => clock,
            input     => buttons_n,
            reset     => resetSynch,
            debounced => buttons
        );
    I_filtG : spikeFilter
        GENERIC MAP (
            counterBitNb => spikeFilterCounterBitNb,
            invertInput  => '0'
        )
        PORT MAP (
            clock    => clock,
            input    => generator,
            reset    => resetSynch,
            filtered => generatorSynch
        );
    I_filtM : spikeFilter
        GENERIC MAP (
            counterBitNb => spikeFilterCounterBitNb,
            invertInput  => '0'
        )
        PORT MAP (
            clock    => clock,
            input    => mains,
            reset    => resetSynch,
            filtered => mainsSynch
        );
    I26 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => testOut(1),
            out1 => LED2
        );
    I27 : bufferUlogic
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => testOut(2),
            out1 => LED1
        );
    I1 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => reset_n,
            out1 => reset
        );
    I7 : inverter
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            in1  => resetSynch_n,
            out1 => resetSynch
        );
    I5 : logic1
        PORT MAP (
            logic_1 => logic_1
        );
    I28 : logic1
        PORT MAP (
            logic_1 => reset1
        );
    I_controller : generatorControl
        GENERIC MAP (
            clockFrequency         => clockFrequency,
            rs232BaudRate          => rs232BaudRate,
            pwmFrequency           => pwmFrequency,
            mainsFrequency         => mainsFrequency,
            buttonsRepeatFrequency => buttonsRepeatFrequency,
            controlAmplitudeBitNb  => controlAmplitudeBitNb,
            proportionalShift      => proportionalShift,
            integratorShift        => integratorShift,
            buttonNb               => buttonNb,
            ledNb                  => ledNb,
            testLineNb             => testLineNb
        )
        PORT MAP (
            RxD       => RxDSynch,
            buttons   => buttonsSynch,
            clock     => clock,
            generator => generatorSynch,
            mains     => mainsSynch,
            reset     => resetSynch,
            TxD       => TxD,
            leds      => LEDs,
            pwm       => pwm,
            testOut   => testOut
        );
    I_rst : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => reset1,
            Q   => resetSynch_n
        );
    I_rst1 : DFF
        GENERIC MAP (
            delay => 1 ns
        )
        PORT MAP (
            CLK => clock,
            CLR => resetSynch,
            D   => RxD,
            Q   => RxDSynch
        );
    I_synchButtons : registerULogicVectorTo
        GENERIC MAP (
            delay         => gateDelay,
            registerBitNb => buttonNb
        )
        PORT MAP (
            clock   => clock,
            dataIn  => buttons,
            enable  => logic_1,
            reset   => resetSynch,
            dataOut => buttonsSynch
        );

END struct;




