--
-- VHDL Architecture GeneratorControl.buttonControl.fsm
--
-- Created:
--          by - francois.francois (Hyperion)
--          at - 09:25:48 09/20/22
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.3 (Build 4)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF buttonControl IS

   TYPE STATE_TYPE IS (
      PIMode,
      toManualMode,
      manualMode,
      incPressed,
      incWaitForRelease,
      decPressed,
      incWaitForRelease1,
      toIMode,
      IMode,
      toUartMode,
      uartMode,
      toPIMode
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clock,
      reset
   )
   -----------------------------------------------------------------
   BEGIN
      IF (reset = '1') THEN
         current_state <= PIMode;
      ELSIF (clock'EVENT AND clock = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      counterDone,
      current_state,
      decrease,
      increase,
      selectToggle
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN PIMode => 
            IF (selectToggle = '1') THEN 
               next_state <= toManualMode;
            ELSE
               next_state <= PIMode;
            END IF;
         WHEN toManualMode => 
            IF (selectToggle = '0') THEN 
               next_state <= manualMode;
            ELSE
               next_state <= toManualMode;
            END IF;
         WHEN manualMode => 
            IF (increase = '1') THEN 
               next_state <= incPressed;
            ELSIF (decrease = '1') THEN 
               next_state <= decPressed;
            ELSIF (selectToggle = '1') THEN 
               next_state <= toIMode;
            ELSE
               next_state <= manualMode;
            END IF;
         WHEN incPressed => 
            next_state <= incWaitForRelease;
         WHEN incWaitForRelease => 
            IF ((increase = '0') or (counterDone = '1')) THEN 
               next_state <= manualMode;
            ELSE
               next_state <= incWaitForRelease;
            END IF;
         WHEN decPressed => 
            next_state <= incWaitForRelease1;
         WHEN incWaitForRelease1 => 
            IF ((decrease = '0') or (counterDone = '1')) THEN 
               next_state <= manualMode;
            ELSE
               next_state <= incWaitForRelease1;
            END IF;
         WHEN toIMode => 
            IF (selectToggle = '0') THEN 
               next_state <= IMode;
            ELSE
               next_state <= toIMode;
            END IF;
         WHEN IMode => 
            IF (selectToggle = '1') THEN 
               next_state <= toUartMode;
            ELSE
               next_state <= IMode;
            END IF;
         WHEN toUartMode => 
            IF (selectToggle = '0') THEN 
               next_state <= uartMode;
            ELSE
               next_state <= toUartMode;
            END IF;
         WHEN uartMode => 
            IF (selectToggle = '1') THEN 
               next_state <= toPIMode;
            ELSE
               next_state <= uartMode;
            END IF;
         WHEN toPIMode => 
            IF (selectToggle = '0') THEN 
               next_state <= PIMode;
            ELSE
               next_state <= toPIMode;
            END IF;
         WHEN OTHERS =>
            next_state <= PIMode;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      decrement <= '0';
      increment <= '0';
      restartCounter <= '0';
      selectManual <= '0';
      selectRegType <= (others => '0');

      -- Combined Actions
      CASE current_state IS
         WHEN PIMode => 
            selectRegType <= "00";
         WHEN toManualMode => 
            selectRegType <= "01";
            selectManual <= '1';
         WHEN manualMode => 
            selectRegType <= "01";
            selectManual <= '1';
         WHEN incPressed => 
            selectRegType <= "01";
            selectManual <= '1';
            increment <= '1';
            restartCounter <= '1';
         WHEN incWaitForRelease => 
            selectRegType <= "01";
            selectManual <= '1';
         WHEN decPressed => 
            selectRegType <= "01";
            selectManual <= '1';
            decrement <= '1';
            restartCounter <= '1';
         WHEN incWaitForRelease1 => 
            selectRegType <= "01";
            selectManual <= '1';
         WHEN toIMode => 
            selectRegType <= "10";
         WHEN IMode => 
            selectRegType <= "10";
         WHEN toUartMode => 
            selectRegType <= "11";
         WHEN uartMode => 
            selectRegType <= "11";
         WHEN toPIMode => 
            selectRegType <= "00";
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
